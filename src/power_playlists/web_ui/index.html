<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Power Playlists Configuration Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }

        .toolbar {
            background: white;
            border-bottom: 1px solid #e0e0e0;
            padding: 12px 20px;
            display: flex;
            gap: 12px;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn {
            background: #007acc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #005a9e;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .status-bar {
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
            padding: 8px 20px;
            font-size: 12px;
            color: #6c757d;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .canvas-container {
            position: relative;
            width: 100vw;
            height: calc(100vh - 120px);
            overflow: hidden;
            background: #fafafa;
        }

        .canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        .canvas.dragging {
            cursor: grabbing;
        }

        .node {
            position: absolute;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            min-width: 180px;
            padding: 0;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .node:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transform: translateY(-1px);
        }

        .node.selected {
            border-color: #007acc;
            box-shadow: 0 0 0 2px rgba(0,122,204,0.2);
        }

        .node-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 16px;
            border-radius: 7px 7px 0 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .node-icon {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        .node-name {
            font-weight: 600;
            font-size: 14px;
        }

        .node-body {
            padding: 12px 16px;
            background: white;
            border-radius: 0 0 7px 7px;
        }

        .node-property {
            font-size: 12px;
            color: #374151;
            margin-bottom: 4px;
        }

        .node-property:last-child {
            margin-bottom: 0;
        }

        .node-property strong {
            color: #1f2937;
        }

        .connection {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .connection-line {
            stroke: #6b7280;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5, 5;
        }

        .template-connection {
            stroke: #e74c3c;
            stroke-width: 2;
            stroke-dasharray: 8, 4;
            fill: none;
        }

        .connection-arrow {
            fill: #6b7280;
        }

        .node {
            --node-color: #7f8c8d;
        }

        .node-header {
            background: linear-gradient(135deg, var(--node-color) 0%, color-mix(in srgb, var(--node-color) 80%, #000) 100%);
            color: white;
            padding: 8px 12px;
            border-radius: 6px 6px 0 0;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 14px;
        }

        .node-icon {
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            padding: 4px;
            font-size: 16px;
            line-height: 1;
            min-width: 24px;
            text-align: center;
        }

        .node-type-playlist .node-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .node-type-playlist .node-icon {
            background: rgba(255,255,255,0.2);
        }

        .node-type-filter .node-header {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .node-type-filter .node-icon {
            background: rgba(255,255,255,0.2);
        }

        .node-type-output .node-header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .node-type-output .node-icon {
            background: rgba(255,255,255,0.2);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            margin-bottom: 4px;
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        .form-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 14px;
        }

        .form-input:focus {
            outline: none;
            border-color: #007acc;
            box-shadow: 0 0 0 2px rgba(0,122,204,0.2);
        }

        .checkbox-list {
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 8px;
            max-height: 120px;
            overflow-y: auto;
            background: white;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .checkbox-item:hover {
            background-color: #f8f9fa;
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 8px;
            width: auto;
        }

        .checkbox-item label {
            margin: 0;
            font-weight: normal;
            cursor: pointer;
            flex: 1;
        }

        .checkbox-list-empty {
            color: #6b7280;
            font-style: italic;
            text-align: center;
            padding: 12px;
        }

        .form-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        /* Template View Styles */
        .template-view {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #fafafa;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .template-header {
            background: white;
            border-bottom: 1px solid #e0e0e0;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .template-breadcrumb {
            font-size: 16px;
            color: #333;
            font-weight: 500;
        }

        .template-actions {
            display: flex;
            gap: 12px;
        }

        .template-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .template-sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #e0e0e0;
            padding: 20px;
            overflow-y: auto;
        }

        .template-sidebar h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .template-canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .template-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        .template-canvas.dragging {
            cursor: grabbing;
        }

        .template-variable {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px 12px;
            margin: 4px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #495057;
        }

        .template-instance {
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            margin: 8px 0;
        }

        .template-instance-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .template-instance-title {
            font-weight: 600;
            color: #495057;
        }

        .template-instance-remove {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        .template-instance-vars {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 12px;
        }

        .template-instance-var {
            display: flex;
            flex-direction: column;
        }

        .template-instance-var label {
            font-weight: 500;
            color: #666;
            margin-bottom: 2px;
        }

        .template-instance-var input {
            padding: 4px 6px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 12px;
        }

        /* Highlight placeholders in template nodes */
        .template-placeholder {
            background: #fff3cd;
            border: 1px dashed #ffc107;
            border-radius: 3px;
            padding: 1px 3px;
            font-weight: 600;
            color: #856404;
        }

        /* Mini-graph styling */
        .mini-graph-container {
            background: #f8f9fa !important;
            border: 1px solid #dee2e6 !important;
            border-radius: 4px !important;
            margin: 2px !important;
            padding: 4px !important;
        }

        .mini-graph-content svg {
            pointer-events: none;
        }

        /* Dynamic template nodes need variable width based on content */
        .node.node-type-dynamic_template {
            min-width: 400px;
            max-width: none;
            width: auto;
        }

        .node.node-type-dynamic_template .node-body {
            overflow: visible;
        }

        .template-instance-full {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .template-instance-node {
            transition: all 0.2s ease;
        }

        .template-instance-node:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="btn" id="loadBtn">Load</button>
        <button class="btn" id="saveBtn">Save</button>
        <button class="btn" id="saveAsBtn">Save As</button>
        <div style="margin-left: auto; display: flex; gap: 12px;">
            <button class="btn btn-secondary" id="addNodeBtn">Add Node</button>
        </div>
    </div>

    <div class="canvas-container">
        <div class="canvas" id="canvas">
            <svg id="connections" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
            </svg>
        </div>
    </div>

    <div class="status-bar">
        <span id="statusText">Ready - Configuration loaded automatically</span>
    </div>

    <!-- Node Edit Modal -->
    <div class="modal hidden" id="editModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Edit Node</h2>
            </div>
            <div id="modalForm">
                <!-- Form fields will be generated here -->
            </div>
            <div class="form-actions">
                <button class="btn btn-secondary" id="cancelBtn">Cancel</button>
                <button class="btn" id="saveNodeBtn">Save</button>
            </div>
        </div>
    </div>

    <!-- Error Display Modal -->
    <div class="modal hidden" id="errorModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Error</h2>
            </div>
            <div id="errorMessage" style="padding: 20px; color: #e74c3c; white-space: pre-wrap;"></div>
            <div class="form-actions">
                <button class="btn" id="errorOkBtn">OK</button>
            </div>
        </div>
    </div>

    <!-- Add Node Modal -->
    <div class="modal hidden" id="addNodeModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Add New Node</h2>
            </div>
            <div style="padding: 20px;">
                <div class="form-group">
                    <label class="form-label">Node ID:</label>
                    <input class="form-input" id="newNodeId" type="text" placeholder="Enter unique node ID">
                </div>
                <div class="form-group">
                    <label class="form-label">Node Type:</label>
                    <select class="form-input" id="newNodeType">
                        <option value="">Select node type...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Description:</label>
                    <div id="nodeTypeDescription" style="font-size: 14px; color: #666; margin-top: 8px;"></div>
                </div>
            </div>
            <div class="form-actions">
                <button class="btn btn-secondary" id="addNodeCancelBtn">Cancel</button>
                <button class="btn" id="addNodeConfirmBtn">Add Node</button>
            </div>
        </div>
    </div>

    <!-- Template View -->
    <div class="template-view hidden" id="templateView">
        <div class="template-header">
            <div class="template-breadcrumb">
                <span id="templateBreadcrumb">Overview > Template: [Template Name]</span>
            </div>
            <div class="template-actions">
                <button class="btn btn-secondary" id="exitTemplateBtn">← Back to Overview</button>
                <button class="btn" id="saveTemplateBtn">Save Template</button>
            </div>
        </div>
        <div class="template-content">
            <div class="template-sidebar">
                <h3>Template Variables</h3>
                <div id="templateVariables">
                    <!-- Variables will be populated here -->
                </div>
                <h3>Instances</h3>
                <div id="templateInstances">
                    <!-- Instances will be populated here -->
                </div>
                <button class="btn" id="addInstanceBtn">Add Instance</button>
            </div>
            <div class="template-canvas-container">
                <div class="template-canvas" id="templateCanvas">
                    <svg id="templateConnections" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></svg>
                </div>
            </div>
        </div>
    </div>

    <script>
        class ConfigurationEditor {
            constructor() {
                this.nodes = new Map();
                this.connections = [];
                this.selectedNode = null;
                this.dragOffset = { x: 0, y: 0 };
                this.isDragging = false;
                this.canvasOffset = { x: 0, y: 0 };
                this.currentConfig = null;
                this.nodeSchemas = null;

                // Template view properties
                this.isInTemplateView = false;
                this.currentTemplateNodeId = null;
                this.templateNodes = new Map();
                this.templateConnections = [];
                this.templateCanvasOffset = { x: 0, y: 0 };

                this.initializeElements();
                this.setupEventListeners();
                this.loadNodeSchemas().then(() => {
                    this.loadInitialConfiguration();
                });
            }

            initializeElements() {
                this.canvas = document.getElementById('canvas');
                this.connectionsContainer = document.getElementById('connections');
                this.statusText = document.getElementById('statusText');
                this.editModal = document.getElementById('editModal');
                this.modalTitle = document.getElementById('modalTitle');
                this.modalForm = document.getElementById('modalForm');
                this.errorModal = document.getElementById('errorModal');
                this.errorMessage = document.getElementById('errorMessage');
                this.addNodeModal = document.getElementById('addNodeModal');

                // Template view elements
                this.templateView = document.getElementById('templateView');
                this.templateBreadcrumb = document.getElementById('templateBreadcrumb');
                this.templateCanvas = document.getElementById('templateCanvas');
                this.templateConnections = document.getElementById('templateConnections');
                this.templateVariables = document.getElementById('templateVariables');
                this.templateInstances = document.getElementById('templateInstances');
            }

            setupEventListeners() {
                // Toolbar buttons
                document.getElementById('loadBtn').addEventListener('click', () => this.loadConfiguration());
                document.getElementById('saveBtn').addEventListener('click', () => this.saveConfiguration());
                document.getElementById('saveAsBtn').addEventListener('click', () => this.saveAsConfiguration());
                document.getElementById('addNodeBtn').addEventListener('click', () => this.showAddNodeModal());

                // Modal buttons
                document.getElementById('cancelBtn').addEventListener('click', () => this.closeModal());
                document.getElementById('saveNodeBtn').addEventListener('click', () => this.saveNodeChanges());
                document.getElementById('errorOkBtn').addEventListener('click', () => this.closeErrorModal());
                document.getElementById('addNodeCancelBtn').addEventListener('click', () => this.closeAddNodeModal());
                document.getElementById('addNodeConfirmBtn').addEventListener('click', () => this.confirmAddNode());

                // Node type selection
                document.getElementById('newNodeType').addEventListener('change', (e) => this.updateNodeTypeDescription(e.target.value));

                // Template view buttons
                document.getElementById('exitTemplateBtn').addEventListener('click', () => this.exitTemplateView());
                document.getElementById('saveTemplateBtn').addEventListener('click', () => this.saveTemplate());
                document.getElementById('addInstanceBtn').addEventListener('click', () => this.addTemplateInstance());

                // Canvas events
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));

                // Prevent context menu
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            async loadNodeSchemas() {
                try {
                    const response = await fetch('/api/node-schema');
                    if (response.ok) {
                        const data = await response.json();
                        this.nodeSchemas = data.schemas;
                        this.populateNodeTypeSelector();
                    } else {
                        console.error('Failed to load node schemas');
                    }
                } catch (error) {
                    console.error('Error loading node schemas:', error);
                }
            }

            populateNodeTypeSelector() {
                const selector = document.getElementById('newNodeType');
                selector.innerHTML = '<option value="">Select node type...</option>';
                
                if (this.nodeSchemas) {
                    Object.entries(this.nodeSchemas).forEach(([type, schema]) => {
                        const option = document.createElement('option');
                        option.value = type;
                        option.textContent = `${schema.icon} ${schema.name}`;
                        selector.appendChild(option);
                    });
                }
            }

            updateNodeTypeDescription(nodeType) {
                const descElement = document.getElementById('nodeTypeDescription');
                if (nodeType && this.nodeSchemas && this.nodeSchemas[nodeType]) {
                    descElement.textContent = this.nodeSchemas[nodeType].description;
                } else {
                    descElement.textContent = '';
                }
            }

            showError(message) {
                this.errorMessage.textContent = message;
                this.errorModal.classList.remove('hidden');
            }

            closeErrorModal() {
                this.errorModal.classList.add('hidden');
            }

            showAddNodeModal() {
                document.getElementById('newNodeId').value = '';
                document.getElementById('newNodeType').value = '';
                this.updateNodeTypeDescription('');
                this.addNodeModal.classList.remove('hidden');
            }

            closeAddNodeModal() {
                this.addNodeModal.classList.add('hidden');
            }

            confirmAddNode() {
                const nodeId = document.getElementById('newNodeId').value.trim();
                const nodeType = document.getElementById('newNodeType').value;
                
                if (!nodeId) {
                    this.showError('Please enter a node ID');
                    return;
                }
                
                if (!nodeType) {
                    this.showError('Please select a node type');
                    return;
                }
                
                if (this.nodes.has(nodeId)) {
                    this.showError('Node ID already exists!');
                    return;
                }

                this.createNewNode(nodeId, nodeType);
                this.closeAddNodeModal();
            }

            createNewNode(nodeId, nodeType) {
                if (!this.nodeSchemas || !this.nodeSchemas[nodeType]) {
                    this.showError('Invalid node type');
                    return;
                }

                const schema = this.nodeSchemas[nodeType];
                const nodeData = { type: nodeType };

                // Set default values for properties
                Object.entries(schema.properties).forEach(([prop, config]) => {
                    if (config.default !== undefined) {
                        nodeData[prop] = config.default;
                    }
                });

                // Find position for new node
                const existingNodes = Array.from(this.nodes.values());
                const x = 50 + (existingNodes.length % 4) * 220;
                const y = 50 + Math.floor(existingNodes.length / 4) * 180;

                this.createNode(nodeId, nodeData, x, y);
                this.updateConnections();
                this.statusText.textContent = `Added new ${schema.name} node: ${nodeId}`;
            }

            async loadInitialConfiguration() {
                try {
                    const response = await fetch('/api/load');
                    if (response.ok) {
                        const config = await response.json();
                        this.displayConfiguration(config);
                        this.statusText.textContent = `Loaded: ${config.filename || 'configuration'}`;
                    } else {
                        this.statusText.textContent = 'No configuration loaded - use Load button';
                    }
                } catch (error) {
                    console.error('Failed to load initial configuration:', error);
                    this.statusText.textContent = 'Failed to load initial configuration';
                }
            }

            async loadConfiguration() {
                try {
                    const response = await fetch('/api/load');
                    if (response.ok) {
                        const config = await response.json();
                        this.displayConfiguration(config);
                        this.statusText.textContent = `Loaded: ${config.filename || 'configuration'}`;
                    } else {
                        this.statusText.textContent = 'Failed to load configuration';
                    }
                } catch (error) {
                    console.error('Failed to load configuration:', error);
                    this.statusText.textContent = 'Error loading configuration';
                }
            }

            async saveConfiguration() {
                try {
                    const config = this.serializeConfiguration();
                    const response = await fetch('/api/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(config)
                    });
                    
                    if (response.ok) {
                        this.statusText.textContent = 'Configuration saved successfully';
                    } else {
                        const errorData = await response.json();
                        this.showError(errorData.error || 'Failed to save configuration');
                        this.statusText.textContent = 'Failed to save configuration';
                    }
                } catch (error) {
                    console.error('Failed to save configuration:', error);
                    this.showError('Error saving configuration: ' + error.message);
                    this.statusText.textContent = 'Error saving configuration';
                }
            }

            async saveAsConfiguration() {
                const filename = prompt('Enter filename (without .yaml extension):');
                if (!filename) return;

                try {
                    const config = this.serializeConfiguration();
                    const response = await fetch('/api/save-as', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ ...config, filename: filename + '.yaml' })
                    });
                    
                    if (response.ok) {
                        this.statusText.textContent = `Saved as: ${filename}.yaml`;
                    } else {
                        const errorData = await response.json();
                        this.showError(errorData.error || 'Failed to save configuration');
                        this.statusText.textContent = 'Failed to save configuration';
                    }
                } catch (error) {
                    console.error('Failed to save configuration:', error);
                    this.showError('Error saving configuration: ' + error.message);
                    this.statusText.textContent = 'Error saving configuration';
                }
            }

            displayConfiguration(config) {
                this.currentConfig = config;
                this.clearCanvas();

                const nodeEntries = Object.entries(config.data || {});
                const nodesPerRow = 4;
                const nodeSpacing = { x: 220, y: 180 };
                const startPos = { x: 50, y: 50 };

                nodeEntries.forEach(([nodeId, nodeData], index) => {
                    const row = Math.floor(index / nodesPerRow);
                    const col = index % nodesPerRow;
                    const x = startPos.x + col * nodeSpacing.x;
                    const y = startPos.y + row * nodeSpacing.y;

                    this.createNode(nodeId, nodeData, x, y);
                });

                this.updateConnections();
            }

            createNode(nodeId, nodeData, x, y) {
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;
                
                const nodeType = nodeData.type || 'unknown';
                nodeElement.classList.add(`node-type-${nodeType}`);

                const schema = this.nodeSchemas && this.nodeSchemas[nodeType];
                const icon = schema ? schema.icon : this.getNodeIcon(nodeType);
                const color = schema ? schema.color : this.getNodeColor(nodeType);
                
                // Set node color
                nodeElement.style.setProperty('--node-color', color);

                let content;
                if (nodeType === 'dynamic_template') {
                    content = this.formatDynamicTemplateNode(nodeId, nodeData, schema);
                } else {
                    const properties = this.formatNodeProperties(nodeData, schema);
                    content = `
                        <div class="node-header">
                            <div class="node-icon">${icon}</div>
                            <div class="node-name">${nodeId}</div>
                        </div>
                        <div class="node-body">
                            ${properties}
                        </div>
                    `;
                }

                nodeElement.innerHTML = content;

                nodeElement.addEventListener('dblclick', () => this.editNode(nodeId));
                nodeElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectNode(nodeElement);
                });

                this.canvas.appendChild(nodeElement);
                this.nodes.set(nodeId, {
                    element: nodeElement,
                    data: { ...nodeData },
                    position: { x, y }
                });
            }

            getNodeColor(nodeType) {
                const colors = {
                    'playlist': '#8E44AD',
                    'liked_tracks': '#E74C3C',
                    'output': '#2ECC71',
                    'combiner': '#F39C12',
                    'limit': '#34495E',
                    'sort': '#3498DB',
                    'filter_eval': '#E67E22',
                    'is_liked': '#E91E63',
                    'dedup': '#95A5A6'
                };
                return colors[nodeType] || '#7f8c8d';
            }

            getNodeIcon(nodeType) {
                const icons = {
                    'playlist': '♫',
                    'output': '📤',
                    'is_liked': '❤️',
                    'is_disliked': '💔',
                    'filter': '🔍',
                    'limit': '📊',
                    'shuffle': '🔀',
                    'sort': '📶'
                };
                return icons[nodeType] || '📦';
            }

            formatNodeProperties(nodeData, schema = null) {
                const excludeKeys = ['input', 'inputs', 'type'];
                const properties = Object.entries(nodeData)
                    .filter(([key]) => !excludeKeys.includes(key))
                    .slice(0, 4)
                    .map(([key, value]) => {
                        let displayValue = String(value);
                        if (displayValue.length > 25) {
                            displayValue = displayValue.substring(0, 22) + '...';
                        }
                        
                        // Use schema description if available
                        let keyDisplay = key;
                        if (schema && schema.properties && schema.properties[key]) {
                            const propSchema = schema.properties[key];
                            if (propSchema.description) {
                                keyDisplay = `${key}`;
                            }
                        }
                        
                        return `<div class="node-property"><strong>${keyDisplay}:</strong> ${displayValue}</div>`;
                    })
                    .join('');
                
                return properties || '<div class="node-property">No additional properties</div>';
            }

            formatDynamicTemplateNode(nodeId, nodeData, schema) {
                const icon = schema ? schema.icon : '🔄';
                const instances = nodeData.instances || [];
                const templateNodes = nodeData.template || {};
                
                // Calculate total layout dimensions
                const templateNodeCount = Object.keys(templateNodes).length;
                const instanceCount = instances.length;
                
                // Layout parameters for full-sized nodes
                const fullNodeWidth = 180;
                const fullNodeHeight = 80;
                const nodeSpacing = { x: 200, y: 100 };
                const instanceSpacing = { x: 50, y: 50 };
                
                // Calculate template node dimensions
                const nodesPerRow = Math.max(1, Math.min(4, templateNodeCount));
                const templateRows = Math.ceil(templateNodeCount / nodesPerRow);
                const templateWidth = nodesPerRow * fullNodeWidth + (nodesPerRow - 1) * nodeSpacing.x;
                const templateHeight = templateRows * fullNodeHeight + (templateRows - 1) * nodeSpacing.y;
                
                // Calculate overall dimensions
                const instanceRows = Math.ceil(instanceCount / 2);
                const totalWidth = Math.max(400, templateWidth + 100);
                const totalHeight = instanceRows * (templateHeight + instanceSpacing.y) + 100;
                
                // Generate all resolved instances
                const resolvedInstances = this.generateResolvedInstances(templateNodes, instances);
                
                return `
                    <div class="node-header">
                        <div class="node-icon">${icon}</div>
                        <div class="node-name">${nodeId}</div>
                    </div>
                    <div class="node-body" style="width: ${totalWidth}px; height: ${totalHeight}px; position: relative;">
                        <div class="node-property"><strong>Template:</strong> ${templateNodeCount} nodes</div>
                        <div class="node-property"><strong>Instances:</strong> ${instanceCount}</div>
                        <div class="template-instances-container" style="margin-top: 16px; position: relative;">
                            ${this.renderAllTemplateInstances(resolvedInstances, nodeId, totalWidth)}
                        </div>
                        <div style="margin-top: 12px; font-size: 11px; color: #007acc; font-style: italic; text-align: center;">
                            Double-click to edit template
                        </div>
                    </div>
                `;
            }

            generateResolvedInstances(templateNodes, instances) {
                const resolved = [];
                
                instances.forEach((instance, instanceIndex) => {
                    const resolvedNodes = {};
                    
                    // Resolve each template node for this instance
                    Object.entries(templateNodes).forEach(([templateNodeId, templateNodeData]) => {
                        // Replace variables in node ID
                        let resolvedId = templateNodeId;
                        Object.entries(instance).forEach(([variable, value]) => {
                            const placeholder = `{${variable}}`;
                            resolvedId = resolvedId.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), String(value));
                        });
                        
                        // Replace variables in node data
                        const resolvedData = this.resolveTemplateVariablesInObject(templateNodeData, instance);
                        
                        resolvedNodes[resolvedId] = {
                            ...resolvedData,
                            originalTemplateId: templateNodeId,
                            instanceIndex: instanceIndex
                        };
                    });
                    
                    resolved.push({
                        instance: instance,
                        instanceIndex: instanceIndex,
                        nodes: resolvedNodes
                    });
                });
                
                return resolved;
            }

            resolveTemplateVariablesInObject(obj, instance) {
                if (typeof obj === 'string') {
                    let resolved = obj;
                    Object.entries(instance).forEach(([variable, value]) => {
                        const placeholder = `{${variable}}`;
                        resolved = resolved.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), String(value));
                    });
                    return resolved;
                } else if (Array.isArray(obj)) {
                    return obj.map(item => this.resolveTemplateVariablesInObject(item, instance));
                } else if (obj !== null && typeof obj === 'object') {
                    const resolved = {};
                    Object.entries(obj).forEach(([key, value]) => {
                        resolved[key] = this.resolveTemplateVariablesInObject(value, instance);
                    });
                    return resolved;
                }
                return obj;
            }

            renderAllTemplateInstances(resolvedInstances, templateNodeId, totalWidth) {
                let html = '';
                let currentY = 0;
                
                resolvedInstances.forEach((resolvedInstance, index) => {
                    const instanceName = this.getInstanceDisplayName(resolvedInstance.instance);
                    const instanceHeight = this.calculateInstanceHeight(resolvedInstance.nodes);
                    
                    html += `
                        <div class="template-instance-full" style="position: absolute; top: ${currentY}px; left: 0; width: 100%; border: 2px solid #dee2e6; border-radius: 8px; background: #f8f9fa; padding: 12px; margin-bottom: 20px;">
                            <div style="font-weight: bold; margin-bottom: 12px; font-size: 12px; color: #495057; text-align: center; border-bottom: 1px solid #dee2e6; padding-bottom: 8px;">
                                Instance ${index + 1}: ${instanceName}
                            </div>
                            <div style="position: relative; min-height: ${instanceHeight}px;">
                                ${this.renderInstanceNodes(resolvedInstance.nodes, resolvedInstance.instanceIndex, templateNodeId)}
                            </div>
                        </div>
                    `;
                    
                    currentY += instanceHeight + 40; // Add spacing between instances
                });
                
                return html;
            }

            calculateInstanceHeight(nodes) {
                const nodeCount = Object.keys(nodes).length;
                const nodesPerRow = Math.min(3, nodeCount);
                const rows = Math.ceil(nodeCount / nodesPerRow);
                return rows * 100 + Math.max(0, rows - 1) * 20 + 40; // Base height + spacing + padding
            }

            renderInstanceNodes(nodes, instanceIndex, templateNodeId) {
                let html = '';
                let svgConnections = '';
                const nodePositions = {};
                
                // Layout nodes in a grid
                const nodeEntries = Object.entries(nodes);
                const nodesPerRow = Math.min(3, nodeEntries.length);
                const nodeWidth = 160;
                const nodeHeight = 80;
                const spacing = { x: 180, y: 100 };
                
                // Render nodes
                nodeEntries.forEach(([nodeId, nodeData], index) => {
                    const row = Math.floor(index / nodesPerRow);
                    const col = index % nodesPerRow;
                    const x = col * spacing.x + 10;
                    const y = row * spacing.y + 10;
                    
                    nodePositions[nodeId] = { x: x + nodeWidth/2, y: y + nodeHeight/2 };
                    
                    const nodeType = nodeData.type || 'unknown';
                    const schema = this.nodeSchemas && this.nodeSchemas[nodeType];
                    const nodeColor = schema ? schema.color : this.getNodeColor(nodeType);
                    const nodeIcon = schema ? schema.icon : this.getNodeIcon(nodeType);
                    
                    // Format properties for display
                    const properties = this.formatNodeProperties(nodeData, schema);
                    
                    html += `
                        <div class="template-instance-node" style="position: absolute; left: ${x}px; top: ${y}px; width: ${nodeWidth}px; height: ${nodeHeight}px; background: white; border: 2px solid ${nodeColor}; border-radius: 6px; padding: 8px; font-size: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #eee; background: ${nodeColor}; color: white; margin: -8px -8px 6px -8px; padding: 6px 8px; border-top-left-radius: 4px; border-top-right-radius: 4px;">
                                <span style="font-size: 12px;">${nodeIcon}</span>
                                <span style="font-weight: bold; font-size: 10px;">${nodeId}</span>
                            </div>
                            <div style="font-size: 9px; max-height: 45px; overflow: hidden;">
                                ${properties}
                            </div>
                        </div>
                    `;
                });
                
                // Generate connections between nodes
                nodeEntries.forEach(([nodeId, nodeData]) => {
                    const fromPos = nodePositions[nodeId];
                    if (!fromPos) return;
                    
                    // Check for input connections within the template
                    if (nodeData.input && nodePositions[nodeData.input]) {
                        const toPos = nodePositions[nodeData.input];
                        svgConnections += this.createSVGConnection(toPos, fromPos, 'internal');
                    }
                    
                    // Check for multiple inputs within the template
                    if (nodeData.inputs && Array.isArray(nodeData.inputs)) {
                        nodeData.inputs.forEach(inputId => {
                            if (inputId && nodePositions[inputId]) {
                                const toPos = nodePositions[inputId];
                                svgConnections += this.createSVGConnection(toPos, fromPos, 'internal');
                            }
                        });
                    }
                    
                    // Check for external connections (inputs from outside the template)
                    this.addExternalConnectionIndicators(nodeData, fromPos, instanceIndex, templateNodeId);
                });
                
                // Calculate SVG dimensions
                const maxX = Math.max(...Object.values(nodePositions).map(pos => pos.x)) + nodeWidth/2 + 20;
                const maxY = Math.max(...Object.values(nodePositions).map(pos => pos.y)) + nodeHeight/2 + 20;
                
                return `
                    ${html}
                    <svg style="position: absolute; top: 0; left: 0; width: ${maxX}px; height: ${maxY}px; pointer-events: none; z-index: 1;">
                        <defs>
                            <marker id="instance-arrow-${instanceIndex}" markerWidth="8" markerHeight="8" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L6,3 z" fill="#666"/>
                            </marker>
                            <marker id="external-arrow-${instanceIndex}" markerWidth="8" markerHeight="8" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L6,3 z" fill="#e74c3c"/>
                            </marker>
                        </defs>
                        ${svgConnections}
                    </svg>
                `;
            }

            createSVGConnection(fromPos, toPos, type) {
                const markerType = type === 'external' ? 'external-arrow' : 'instance-arrow';
                const strokeColor = type === 'external' ? '#e74c3c' : '#666';
                const strokeWidth = type === 'external' ? '2' : '1.5';
                
                // Create curved connection
                const controlPoint1X = fromPos.x + (toPos.x - fromPos.x) * 0.5;
                const controlPoint1Y = fromPos.y;
                const controlPoint2X = toPos.x - (toPos.x - fromPos.x) * 0.5;
                const controlPoint2Y = toPos.y;
                
                return `
                    <path d="M ${fromPos.x} ${fromPos.y} C ${controlPoint1X} ${controlPoint1Y} ${controlPoint2X} ${controlPoint2Y} ${toPos.x} ${toPos.y}"
                          stroke="${strokeColor}" stroke-width="${strokeWidth}" fill="none" 
                          marker-end="url(#${markerType}-${Math.floor(Math.random() * 10000)})"/>
                `;
            }

            addExternalConnectionIndicators(nodeData, nodePos, instanceIndex, templateNodeId) {
                // This method would be used to show external connections
                // For now, we'll add visual indicators for external references
                const configData = this.currentConfig?.data || this.currentConfig || {};
                
                // Check if input references external nodes
                if (nodeData.input && !this.isTemplateInternalNode(nodeData.input, templateNodeId)) {
                    // Add external connection indicator - this could be enhanced further
                }
                
                if (nodeData.inputs && Array.isArray(nodeData.inputs)) {
                    nodeData.inputs.forEach(inputId => {
                        if (inputId && !this.isTemplateInternalNode(inputId, templateNodeId)) {
                            // Add external connection indicator
                        }
                    });
                }
            }

            isTemplateInternalNode(nodeId, templateNodeId) {
                // Check if the node ID corresponds to a template-internal node
                const configData = this.currentConfig?.data || this.currentConfig || {};
                const templateData = configData[templateNodeId];
                if (!templateData || !templateData.template) return false;
                
                // Check if it's a template node pattern
                return Object.keys(templateData.template).some(templateKey => {
                    // This is a simplified check - in practice, you'd need to resolve variables
                    return templateKey.includes('{') || nodeId.includes(templateKey.replace(/\{[^}]+\}/g, ''));
                });
            }

            getMiniNodeColor(nodeType) {
                const colors = {
                    'playlist': '#8E44AD',
                    'liked_tracks': '#E74C3C',
                    'all_tracks': '#9B59B6',
                    'output': '#2ECC71',
                    'combiner': '#F39C12',
                    'limit': '#34495E',
                    'sort': '#3498DB',
                    'filter_eval': '#E67E22',
                    'filter_time_added': '#16A085',
                    'filter_release_date': '#8E44AD',
                    'is_liked': '#E91E63',
                    'dedup': '#95A5A6',
                    'dynamic_template': '#17A2B8'
                };
                return colors[nodeType] || '#7f8c8d';
            }

            getMiniNodeIcon(nodeType) {
                const icons = {
                    'playlist': '♫',
                    'liked_tracks': '❤',
                    'all_tracks': '🎵',
                    'output': '📤',
                    'combiner': '➕',
                    'limit': '🔢',
                    'sort': '🔀',
                    'filter_eval': '🔍',
                    'filter_time_added': '⏰',
                    'filter_release_date': '📅',
                    'is_liked': '💖',
                    'dedup': '🎯',
                    'dynamic_template': '🔄'
                };
                return icons[nodeType] || '?';
            }

            getInstanceDisplayName(instance) {
                // Try to find a meaningful name from the instance variables
                const keys = Object.keys(instance);
                if (keys.length === 0) return 'Empty';
                
                // Look for common naming variables
                const nameKeys = ['name', 'title', 'label', 'id'];
                for (const key of nameKeys) {
                    if (instance[key]) return String(instance[key]).substring(0, 8);
                }
                
                // Use first variable value
                const firstValue = String(instance[keys[0]]);
                return firstValue.substring(0, 8) || 'Instance';
            }

            updateConnections() {
                this.connectionsContainer.innerHTML = '';
                this.connections = [];

                // First, collect all template-generated nodes for connection resolution
                const templateGeneratedNodes = this.collectTemplateGeneratedNodes();

                for (const [nodeId, nodeInfo] of this.nodes) {
                    const nodeData = nodeInfo.data;
                    
                    // Handle single input
                    if (nodeData.input) {
                        // Check if input exists as a regular node
                        if (this.nodes.has(nodeData.input)) {
                            this.createConnection(nodeData.input, nodeId);
                        }
                        // Check if input is a template-generated node
                        else if (templateGeneratedNodes.has(nodeData.input)) {
                            this.createTemplateConnection(nodeData.input, nodeId, templateGeneratedNodes);
                        }
                    }

                    // Handle multiple inputs
                    if (nodeData.inputs && Array.isArray(nodeData.inputs)) {
                        nodeData.inputs.forEach(inputId => {
                            if (inputId) {
                                // Check if input exists as a regular node
                                if (this.nodes.has(inputId)) {
                                    this.createConnection(inputId, nodeId);
                                }
                                // Check if input is a template-generated node  
                                else if (templateGeneratedNodes.has(inputId)) {
                                    this.createTemplateConnection(inputId, nodeId, templateGeneratedNodes);
                                }
                            }
                        });
                    }
                }
            }

            collectTemplateGeneratedNodes() {
                const templateNodes = new Map();
                const configData = this.currentConfig?.data || this.currentConfig || {};
                
                // Find all dynamic template nodes and their generated instances
                Object.entries(configData).forEach(([nodeId, nodeData]) => {
                    if (nodeData.type === 'dynamic_template' && nodeData.template && nodeData.instances) {
                        // For each instance, generate the resolved node IDs
                        nodeData.instances.forEach((instance, instanceIndex) => {
                            Object.keys(nodeData.template).forEach(templateNodeId => {
                                // Resolve template variables in the node ID
                                let resolvedNodeId = templateNodeId;
                                Object.entries(instance).forEach(([variable, value]) => {
                                    const placeholder = `{${variable}}`;
                                    resolvedNodeId = resolvedNodeId.replace(
                                        new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), 
                                        String(value)
                                    );
                                });
                                
                                templateNodes.set(resolvedNodeId, {
                                    templateNodeId: nodeId,
                                    instanceIndex: instanceIndex,
                                    originalTemplateKey: templateNodeId
                                });
                            });
                        });
                    }
                });
                
                return templateNodes;
            }

            createTemplateConnection(fromNodeId, toNodeId, templateGeneratedNodes) {
                const templateInfo = templateGeneratedNodes.get(fromNodeId);
                if (!templateInfo) return;
                
                // Find the template node element
                const templateNode = this.nodes.get(templateInfo.templateNodeId);
                if (!templateNode) return;
                
                const toNode = this.nodes.get(toNodeId);
                if (!toNode) return;
                
                // Get the positions
                const templateRect = templateNode.element.getBoundingClientRect();
                const toRect = toNode.element.getBoundingClientRect();
                const canvasRect = this.canvas.getBoundingClientRect();
                
                // Calculate connection points - from template node edge to target node
                const fromX = templateRect.left - canvasRect.left + templateRect.width;
                const fromY = templateRect.top - canvasRect.top + templateRect.height / 2;
                const toX = toRect.left - canvasRect.left;
                const toY = toRect.top - canvasRect.top + toRect.height / 2;
                
                // Create the connection path
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                const controlPoint1X = fromX + (toX - fromX) * 0.5;
                const controlPoint1Y = fromY;
                const controlPoint2X = toX - (toX - fromX) * 0.5;
                const controlPoint2Y = toY;
                
                const pathData = `M ${fromX} ${fromY} C ${controlPoint1X} ${controlPoint1Y} ${controlPoint2X} ${controlPoint2Y} ${toX} ${toY}`;
                
                path.setAttribute("d", pathData);
                path.setAttribute("class", "connection-line template-connection");
                path.setAttribute("stroke", "#e74c3c"); // Different color for template connections
                path.setAttribute("stroke-width", "2");
                path.setAttribute("stroke-dasharray", "5,5"); // Dashed line to indicate template connection
                
                // Add arrow marker for template connections
                const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
                const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
                marker.setAttribute("id", `template-arrow-${fromNodeId}-${toNodeId}`);
                marker.setAttribute("markerWidth", "10");
                marker.setAttribute("markerHeight", "10");
                marker.setAttribute("refX", "8");
                marker.setAttribute("refY", "3");
                marker.setAttribute("orient", "auto");
                marker.setAttribute("markerUnits", "strokeWidth");
                
                const arrowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                arrowPath.setAttribute("d", "M0,0 L0,6 L9,3 z");
                arrowPath.setAttribute("fill", "#e74c3c");
                
                marker.appendChild(arrowPath);
                defs.appendChild(marker);
                this.connectionsContainer.appendChild(defs);
                
                path.setAttribute("marker-end", `url(#template-arrow-${fromNodeId}-${toNodeId})`);
                this.connectionsContainer.appendChild(path);
                
                this.connections.push({ from: fromNodeId, to: toNodeId, element: path, type: 'template' });
            }

            createConnection(fromNodeId, toNodeId) {
                const fromNode = this.nodes.get(fromNodeId);
                const toNode = this.nodes.get(toNodeId);
                
                if (!fromNode || !toNode) return;

                const fromRect = fromNode.element.getBoundingClientRect();
                const toRect = toNode.element.getBoundingClientRect();
                const canvasRect = this.canvas.getBoundingClientRect();

                const fromX = fromRect.left - canvasRect.left + fromRect.width / 2;
                const fromY = fromRect.top - canvasRect.top + fromRect.height / 2;
                const toX = toRect.left - canvasRect.left + toRect.width / 2;
                const toY = toRect.top - canvasRect.top + toRect.height / 2;

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                const controlPoint1X = fromX + (toX - fromX) * 0.5;
                const controlPoint1Y = fromY;
                const controlPoint2X = toX - (toX - fromX) * 0.5;
                const controlPoint2Y = toY;

                const pathData = `M ${fromX} ${fromY} C ${controlPoint1X} ${controlPoint1Y} ${controlPoint2X} ${controlPoint2Y} ${toX} ${toY}`;
                
                path.setAttribute("d", pathData);
                path.setAttribute("class", "connection-line");

                // Add arrow marker
                const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
                const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
                marker.setAttribute("id", `arrow-${fromNodeId}-${toNodeId}`);
                marker.setAttribute("markerWidth", "10");
                marker.setAttribute("markerHeight", "10");
                marker.setAttribute("refX", "8");
                marker.setAttribute("refY", "3");
                marker.setAttribute("orient", "auto");
                marker.setAttribute("markerUnits", "strokeWidth");

                const arrowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                arrowPath.setAttribute("d", "M0,0 L0,6 L9,3 z");
                arrowPath.setAttribute("class", "connection-arrow");

                marker.appendChild(arrowPath);
                defs.appendChild(marker);
                this.connectionsContainer.appendChild(defs);

                path.setAttribute("marker-end", `url(#arrow-${fromNodeId}-${toNodeId})`);
                this.connectionsContainer.appendChild(path);

                this.connections.push({ from: fromNodeId, to: toNodeId, element: path });
            }

            selectNode(nodeElement) {
                // Remove previous selection
                this.nodes.forEach(nodeInfo => {
                    nodeInfo.element.classList.remove('selected');
                });

                // Select new node
                nodeElement.classList.add('selected');
                this.selectedNode = nodeElement;
            }

            editNode(nodeId) {
                const nodeInfo = this.nodes.get(nodeId);
                if (!nodeInfo) return;

                // Special handling for dynamic templates - enter template view instead of editing
                if (nodeInfo.data.type === 'dynamic_template') {
                    this.enterTemplateView(nodeId);
                    return;
                }

                this.modalTitle.textContent = `Edit Node: ${nodeId}`;
                this.currentEditingNode = nodeId;
                
                const nodeType = nodeInfo.data.type;
                const schema = this.nodeSchemas && this.nodeSchemas[nodeType];
                
                // Generate form fields based on schema
                this.modalForm.innerHTML = '';
                
                if (schema) {
                    // Add type field (read-only)
                    const typeGroup = document.createElement('div');
                    typeGroup.className = 'form-group';
                    typeGroup.innerHTML = `
                        <label class="form-label">Type:</label>
                        <input class="form-input" value="${schema.icon} ${schema.name}" readonly style="background: #f5f5f5; color: #666;">
                    `;
                    this.modalForm.appendChild(typeGroup);

                    // Add schema-defined properties
                    Object.entries(schema.properties).forEach(([propName, propConfig]) => {
                        const currentValue = nodeInfo.data[propName] || '';
                        const formGroup = this.createPropertyInput(propName, propConfig, currentValue, nodeId);
                        this.modalForm.appendChild(formGroup);
                    });

                    // Add existing properties not in schema (for backwards compatibility)
                    Object.entries(nodeInfo.data).forEach(([key, value]) => {
                        if (key !== 'type' && !schema.properties[key] && key !== 'input' && key !== 'inputs') {
                            const formGroup = document.createElement('div');
                            formGroup.className = 'form-group';
                            formGroup.innerHTML = `
                                <label class="form-label">${key}: <small style="color: #e67e22;">(custom property)</small></label>
                                <input class="form-input" name="${key}" value="${value || ''}" type="text">
                            `;
                            this.modalForm.appendChild(formGroup);
                        }
                    });
                } else {
                    // Fallback for unknown node types
                    Object.entries(nodeInfo.data).forEach(([key, value]) => {
                        if (key === 'input' || key === 'inputs') return;

                        const formGroup = document.createElement('div');
                        formGroup.className = 'form-group';
                        
                        const isReadonly = key === 'type' ? 'readonly style="background: #f5f5f5; color: #666;"' : '';
                        formGroup.innerHTML = `
                            <label class="form-label">${key}:</label>
                            <input class="form-input" name="${key}" value="${value || ''}" type="text" ${isReadonly}>
                        `;
                        
                        this.modalForm.appendChild(formGroup);
                    });
                }

                this.editModal.classList.remove('hidden');
            }

            createPropertyInput(propName, propConfig, currentValue, nodeId) {
                const formGroup = document.createElement('div');
                formGroup.className = 'form-group';
                
                const isRequired = propConfig.required ? ' <span style="color: #e74c3c;">*</span>' : '';
                const description = propConfig.description ? `<br><small style="color: #666;">${propConfig.description}</small>` : '';
                
                let inputHtml = '';
                
                switch (propConfig.type) {
                    case 'boolean':
                        const checked = currentValue === true || currentValue === 'true' ? 'checked' : '';
                        inputHtml = `<input class="form-input" name="${propName}" type="checkbox" ${checked} style="width: auto;">`;
                        break;
                        
                    case 'integer':
                        inputHtml = `<input class="form-input" name="${propName}" value="${currentValue || ''}" type="number" step="1">`;
                        break;
                        
                    case 'select':
                        const options = propConfig.options || [];
                        const optionsHtml = options.map(option => {
                            const selected = option === currentValue ? 'selected' : '';
                            return `<option value="${option}" ${selected}>${option}</option>`;
                        }).join('');
                        inputHtml = `<select class="form-input" name="${propName}">
                            <option value="">Select ${propName}...</option>
                            ${optionsHtml}
                        </select>`;
                        break;
                        
                    case 'node_reference':
                        const nodeOptions = Array.from(this.nodes.keys()).filter(id => id !== nodeId);
                        const nodeOptionsHtml = nodeOptions.map(nodeId => {
                            const selected = nodeId === currentValue ? 'selected' : '';
                            return `<option value="${nodeId}" ${selected}>${nodeId}</option>`;
                        }).join('');
                        inputHtml = `<select class="form-input" name="${propName}">
                            <option value="">Select node...</option>
                            ${nodeOptionsHtml}
                        </select>`;
                        break;
                        
                    case 'node_list':
                        // Create multi-select checkbox interface for node lists
                        const availableNodes = Array.from(this.nodes.keys()).filter(id => id !== nodeId);
                        const currentValues = Array.isArray(currentValue) ? currentValue : (currentValue ? [currentValue] : []);
                        
                        if (availableNodes.length === 0) {
                            inputHtml = `<div class="checkbox-list">
                                <div class="checkbox-list-empty">No other nodes available</div>
                            </div>`;
                        } else {
                            const checkboxItems = availableNodes.map(nodeOption => {
                                const isChecked = currentValues.includes(nodeOption);
                                const checkboxId = `${propName}_${nodeOption}`;
                                return `<div class="checkbox-item">
                                    <input type="checkbox" id="${checkboxId}" name="${propName}" value="${nodeOption}" ${isChecked ? 'checked' : ''}>
                                    <label for="${checkboxId}">${nodeOption}</label>
                                </div>`;
                            }).join('');
                            
                            inputHtml = `<div class="checkbox-list" name="${propName}">
                                ${checkboxItems}
                            </div>`;
                        }
                        break;
                        
                    default: // text
                        inputHtml = `<input class="form-input" name="${propName}" value="${currentValue || ''}" type="text">`;
                        break;
                }
                
                formGroup.innerHTML = `
                    <label class="form-label">${propName}${isRequired}${description}</label>
                    ${inputHtml}
                `;
                
                return formGroup;
            }

            saveNodeChanges() {
                const nodeInfo = this.nodes.get(this.currentEditingNode);
                if (!nodeInfo) return;

                // First, collect all checkbox lists for node_list properties
                const checkboxLists = {};
                this.modalForm.querySelectorAll('.checkbox-list').forEach(checkboxContainer => {
                    const propertyName = checkboxContainer.getAttribute('name');
                    if (propertyName) {
                        const checkboxes = checkboxContainer.querySelectorAll('input[type="checkbox"]:checked');
                        checkboxLists[propertyName] = Array.from(checkboxes).map(cb => cb.value);
                    }
                });

                // Update properties from all form inputs
                const inputs = this.modalForm.querySelectorAll('input[name], select[name], textarea[name]');
                
                inputs.forEach(input => {
                    const propName = input.name;
                    
                    // Skip checkboxes that are part of checkbox lists (handled above)
                    if (input.type === 'checkbox' && input.closest('.checkbox-list')) {
                        return;
                    }
                    
                    let value = input.value.trim();
                    
                    // Handle different input types
                    if (input.type === 'checkbox') {
                        value = input.checked;
                    } else if (input.type === 'number') {
                        value = value ? parseInt(value) : '';
                    } else if (input.tagName === 'TEXTAREA' && propName === 'inputs') {
                        // Handle legacy node lists (fallback for textarea)
                        if (value) {
                            value = value.split(',').map(s => s.trim()).filter(s => s);
                        } else {
                            value = [];
                        }
                    }
                    
                    // Update the node data
                    if (value !== '') {
                        nodeInfo.data[propName] = value;
                    } else if (nodeInfo.data.hasOwnProperty(propName)) {
                        delete nodeInfo.data[propName];
                    }
                });
                
                // Apply checkbox list values
                Object.entries(checkboxLists).forEach(([propName, values]) => {
                    if (values.length > 0) {
                        nodeInfo.data[propName] = values;
                    } else if (nodeInfo.data.hasOwnProperty(propName)) {
                        delete nodeInfo.data[propName];
                    }
                });

                // Update the visual representation
                const nodeType = nodeInfo.data.type;
                const schema = this.nodeSchemas && this.nodeSchemas[nodeType];
                const properties = this.formatNodeProperties(nodeInfo.data, schema);
                const bodyElement = nodeInfo.element.querySelector('.node-body');
                bodyElement.innerHTML = properties;

                this.closeModal();
                this.statusText.textContent = `Updated node: ${this.currentEditingNode}`;
                
                // Update connections in case inputs changed
                this.updateConnections();
            }

            closeModal() {
                this.editModal.classList.add('hidden');
                this.currentEditingNode = null;
            }

            // Remove old addNewNode - replaced by showAddNodeModal

            clearCanvas() {
                this.canvas.innerHTML = '<svg id="connections" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></svg>';
                this.connectionsContainer = document.getElementById('connections');
                this.nodes.clear();
                this.connections = [];
            }

            serializeConfiguration() {
                const data = {};
                this.nodes.forEach((nodeInfo, nodeId) => {
                    data[nodeId] = { ...nodeInfo.data };
                });
                return { data };
            }

            // Template View Methods
            async enterTemplateView(nodeId) {
                try {
                    this.currentTemplateNodeId = nodeId;
                    
                    const response = await fetch('/api/template/enter', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            nodeId: nodeId,
                            configData: this.currentConfig.data || this.currentConfig
                        })
                    });

                    if (response.ok) {
                        const templateData = await response.json();
                        this.showTemplateView(nodeId, templateData);
                    } else {
                        const error = await response.json();
                        this.showError(`Failed to enter template: ${error.error}`);
                    }
                } catch (error) {
                    this.showError(`Error entering template: ${error.message}`);
                }
            }

            showTemplateView(nodeId, templateData) {
                this.isInTemplateView = true;
                
                // Update breadcrumb
                this.templateBreadcrumb.textContent = `Overview > Template: ${nodeId}`;
                
                // Show template view and hide main view
                this.templateView.classList.remove('hidden');
                
                // Load template nodes
                this.loadTemplateNodes(templateData.templateNodes);
                
                // Show variables and instances
                this.displayTemplateVariables(templateData.variables);
                this.displayTemplateInstances(templateData.instances, templateData.variables);
            }

            loadTemplateNodes(templateNodes) {
                // Clear existing template canvas
                this.templateCanvas.innerHTML = '<svg id="templateConnections" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></svg>';
                this.templateConnections = document.getElementById('templateConnections');
                this.templateNodes.clear();
                this.templateConnections = [];

                // Create nodes with placeholder highlighting
                let x = 50, y = 50;
                for (const [nodeId, nodeData] of Object.entries(templateNodes)) {
                    this.createTemplateNode(nodeId, nodeData, x, y);
                    x += 200;
                    if (x > 800) {
                        x = 50;
                        y += 150;
                    }
                }

                this.updateTemplateConnections();
            }

            createTemplateNode(nodeId, nodeData, x, y) {
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;
                
                const nodeType = nodeData.type || 'unknown';
                nodeElement.classList.add(`node-type-${nodeType}`);

                const schema = this.nodeSchemas && this.nodeSchemas[nodeType];
                const icon = schema ? schema.icon : '?';
                const color = schema ? schema.color : '#95A5A6';
                
                // Set node color
                nodeElement.style.setProperty('--node-color', color);

                // Format properties with placeholder highlighting
                const properties = this.formatTemplateNodeProperties(nodeData, schema);

                nodeElement.innerHTML = `
                    <div class="node-header">
                        <div class="node-icon">${icon}</div>
                        <div class="node-name">${this.highlightPlaceholders(nodeId)}</div>
                    </div>
                    <div class="node-body">
                        ${properties}
                    </div>
                `;

                nodeElement.addEventListener('dblclick', () => this.editTemplateNode(nodeId));
                nodeElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectTemplateNode(nodeElement);
                });

                this.templateCanvas.appendChild(nodeElement);
                this.templateNodes.set(nodeId, {
                    element: nodeElement,
                    data: nodeData,
                    position: { x, y }
                });
            }

            formatTemplateNodeProperties(nodeData, schema) {
                let properties = '';
                
                for (const [key, value] of Object.entries(nodeData)) {
                    if (key === 'type') continue;
                    
                    const displayValue = this.highlightPlaceholders(String(value));
                    properties += `<div class="node-property"><strong>${key}:</strong> ${displayValue}</div>`;
                }
                
                return properties || '<div class="node-property"><em>No properties</em></div>';
            }

            highlightPlaceholders(text) {
                if (typeof text !== 'string') return text;
                return text.replace(/\{([^{}]+)\}/g, '<span class="template-placeholder">{$1}</span>');
            }

            displayTemplateVariables(variables) {
                this.templateVariables.innerHTML = '';
                
                if (variables.length === 0) {
                    this.templateVariables.innerHTML = '<div style="color: #666; font-style: italic;">No variables detected</div>';
                    return;
                }

                variables.forEach(variable => {
                    const varElement = document.createElement('div');
                    varElement.className = 'template-variable';
                    varElement.textContent = `{${variable}}`;
                    this.templateVariables.appendChild(varElement);
                });
            }

            displayTemplateInstances(instances, variables) {
                this.templateInstances.innerHTML = '';
                
                instances.forEach((instance, index) => {
                    const instanceElement = document.createElement('div');
                    instanceElement.className = 'template-instance';
                    
                    const header = document.createElement('div');
                    header.className = 'template-instance-header';
                    header.innerHTML = `
                        <span class="template-instance-title">Instance ${index + 1}</span>
                        <button class="template-instance-remove" onclick="editor.removeTemplateInstance(${index})">Remove</button>
                    `;
                    instanceElement.appendChild(header);

                    const varsContainer = document.createElement('div');
                    varsContainer.className = 'template-instance-vars';
                    
                    variables.forEach(variable => {
                        const varDiv = document.createElement('div');
                        varDiv.className = 'template-instance-var';
                        varDiv.innerHTML = `
                            <label>${variable}:</label>
                            <input type="text" value="${instance[variable] || ''}" 
                                   onchange="editor.updateInstanceVariable(${index}, '${variable}', this.value)">
                        `;
                        varsContainer.appendChild(varDiv);
                    });
                    
                    instanceElement.appendChild(varsContainer);
                    this.templateInstances.appendChild(instanceElement);
                });
            }

            updateTemplateConnections() {
                // Implementation for template connections - simplified for now
                // This would need to be implemented similarly to updateConnections()
                // but for the template canvas
            }

            selectTemplateNode(nodeElement) {
                // Remove previous selection
                this.templateNodes.forEach(nodeInfo => {
                    nodeInfo.element.classList.remove('selected');
                });

                // Select new node
                nodeElement.classList.add('selected');
            }

            editTemplateNode(nodeId) {
                // For now, just show a simple alert - could be expanded to edit template nodes
                alert(`Editing template node: ${nodeId}\nThis feature can be expanded to allow editing template node properties.`);
            }

            exitTemplateView() {
                this.isInTemplateView = false;
                this.currentTemplateNodeId = null;
                this.templateView.classList.add('hidden');
            }

            saveTemplate() {
                // Implementation for saving template changes
                alert('Save template functionality to be implemented');
            }

            addTemplateInstance() {
                // Add a new empty instance
                const configData = this.currentConfig.data || this.currentConfig;
                const nodeData = configData[this.currentTemplateNodeId];
                if (!nodeData.instances) nodeData.instances = [];
                
                // Create new instance with empty values for all variables
                const newInstance = {};
                if (nodeData.instances.length > 0) {
                    // Copy structure from first instance
                    Object.keys(nodeData.instances[0]).forEach(key => {
                        newInstance[key] = '';
                    });
                }
                
                nodeData.instances.push(newInstance);
                
                // Refresh display
                this.enterTemplateView(this.currentTemplateNodeId);
            }

            removeTemplateInstance(index) {
                const configData = this.currentConfig.data || this.currentConfig;
                const nodeData = configData[this.currentTemplateNodeId];
                if (nodeData.instances && nodeData.instances.length > 1) {
                    nodeData.instances.splice(index, 1);
                    this.enterTemplateView(this.currentTemplateNodeId);
                }
            }

            updateInstanceVariable(instanceIndex, variable, value) {
                const configData = this.currentConfig.data || this.currentConfig;
                const nodeData = configData[this.currentTemplateNodeId];
                if (nodeData.instances && nodeData.instances[instanceIndex]) {
                    nodeData.instances[instanceIndex][variable] = value;
                }
            }

            handleMouseDown(e) {
                const nodeElement = e.target.closest('.node');
                if (nodeElement) {
                    const rect = nodeElement.getBoundingClientRect();
                    this.dragOffset = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    this.isDragging = nodeElement;
                    this.selectNode(nodeElement);
                    e.preventDefault();
                }
            }

            handleMouseMove(e) {
                if (this.isDragging) {
                    const x = e.clientX - this.dragOffset.x - this.canvas.getBoundingClientRect().left;
                    const y = e.clientY - this.dragOffset.y - this.canvas.getBoundingClientRect().top;
                    
                    this.isDragging.style.left = `${x}px`;
                    this.isDragging.style.top = `${y}px`;
                    
                    // Update stored position
                    for (const [nodeId, nodeInfo] of this.nodes) {
                        if (nodeInfo.element === this.isDragging) {
                            nodeInfo.position = { x, y };
                            break;
                        }
                    }
                    
                    this.updateConnections();
                }
            }

            handleMouseUp(e) {
                this.isDragging = false;
            }
        }

        // Initialize the editor when the page loads
        let editor;
        document.addEventListener('DOMContentLoaded', () => {
            editor = new ConfigurationEditor();
        });
    </script>
</body>
</html>