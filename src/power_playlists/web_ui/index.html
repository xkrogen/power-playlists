<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Power Playlists Configuration Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }

        .toolbar {
            background: white;
            border-bottom: 1px solid #e0e0e0;
            padding: 12px 20px;
            display: flex;
            gap: 12px;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .btn {
            background: #007acc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #005a9e;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .status-bar {
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
            padding: 8px 20px;
            font-size: 12px;
            color: #6c757d;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .canvas-container {
            position: relative;
            width: 100vw;
            height: calc(100vh - 120px);
            overflow: hidden;
            background: #fafafa;
        }

        .canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        .canvas.dragging {
            cursor: grabbing;
        }

        .node {
            position: absolute;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            min-width: 180px;
            padding: 0;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .node:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            transform: translateY(-1px);
        }

        .node.selected {
            border-color: #007acc;
            box-shadow: 0 0 0 2px rgba(0,122,204,0.2);
        }

        .node-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 16px;
            border-radius: 7px 7px 0 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .node-icon {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        .node-name {
            font-weight: 600;
            font-size: 14px;
        }

        .node-body {
            padding: 12px 16px;
            background: white;
            border-radius: 0 0 7px 7px;
        }

        .node-property {
            font-size: 12px;
            color: #374151;
            margin-bottom: 4px;
        }

        .node-property:last-child {
            margin-bottom: 0;
        }

        .node-property strong {
            color: #1f2937;
        }

        .connection {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        .connection-line {
            stroke: #6b7280;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5, 5;
        }

        .template-connection {
            stroke: #e74c3c;
            stroke-width: 2;
            stroke-dasharray: 8, 4;
            fill: none;
        }

        .connection-arrow {
            fill: #6b7280;
        }

        .node {
            --node-color: #7f8c8d;
        }

        .node-header {
            background: linear-gradient(135deg, var(--node-color) 0%, color-mix(in srgb, var(--node-color) 80%, #000) 100%);
            color: white;
            padding: 8px 12px;
            border-radius: 6px 6px 0 0;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 14px;
        }

        .node-icon {
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            padding: 4px;
            font-size: 16px;
            line-height: 1;
            min-width: 24px;
            text-align: center;
        }

        .node-type-playlist .node-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .node-type-playlist .node-icon {
            background: rgba(255,255,255,0.2);
        }

        .node-type-filter .node-header {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .node-type-filter .node-icon {
            background: rgba(255,255,255,0.2);
        }

        .node-type-output .node-header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .node-type-output .node-icon {
            background: rgba(255,255,255,0.2);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            margin-bottom: 4px;
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        .form-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 14px;
        }

        .form-input:focus {
            outline: none;
            border-color: #007acc;
            box-shadow: 0 0 0 2px rgba(0,122,204,0.2);
        }

        .checkbox-list {
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 8px;
            max-height: 120px;
            overflow-y: auto;
            background: white;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .checkbox-item:hover {
            background-color: #f8f9fa;
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 8px;
            width: auto;
        }

        .checkbox-item label {
            margin: 0;
            font-weight: normal;
            cursor: pointer;
            flex: 1;
        }

        .checkbox-list-empty {
            color: #6b7280;
            font-style: italic;
            text-align: center;
            padding: 12px;
        }

        .form-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        /* Template View Styles */
        .template-view {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #fafafa;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        .template-header {
            background: white;
            border-bottom: 1px solid #e0e0e0;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .template-breadcrumb {
            font-size: 16px;
            color: #333;
            font-weight: 500;
        }

        .template-actions {
            display: flex;
            gap: 12px;
        }

        .template-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .template-sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #e0e0e0;
            padding: 20px;
            overflow-y: auto;
        }

        .template-sidebar h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .template-canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .template-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        .template-canvas.dragging {
            cursor: grabbing;
        }

        .template-variable {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 8px 12px;
            margin: 4px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #495057;
        }

        .template-instance {
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            margin: 8px 0;
        }

        .template-instance-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .template-instance-title {
            font-weight: 600;
            color: #495057;
        }

        .template-instance-remove {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        .template-instance-vars {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 12px;
        }

        .template-instance-var {
            display: flex;
            flex-direction: column;
        }

        .template-instance-var label {
            font-weight: 500;
            color: #666;
            margin-bottom: 2px;
        }

        .template-instance-var input {
            padding: 4px 6px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 12px;
        }

        /* Highlight placeholders in template nodes */
        .template-placeholder {
            background: #fff3cd;
            border: 1px dashed #ffc107;
            border-radius: 3px;
            padding: 1px 3px;
            font-weight: 600;
            color: #856404;
        }

        /* Mini-graph styling */
        .mini-graph-container {
            background: #f8f9fa !important;
            border: 1px solid #dee2e6 !important;
            border-radius: 4px !important;
            margin: 2px !important;
            padding: 4px !important;
        }

        .mini-graph-content svg {
            pointer-events: none;
        }

        /* Dynamic template nodes need variable width based on content */
        .node.node-type-dynamic_template {
            min-width: 400px;
            max-width: none;
            width: auto;
        }

        .node.node-type-dynamic_template .node-body {
            overflow: visible;
        }

        .template-instance-full {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .template-instance-node {
            transition: all 0.2s ease;
        }

        .template-instance-node:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="btn" id="loadBtn">Load</button>
        <button class="btn" id="saveBtn">Save</button>
        <button class="btn" id="saveAsBtn">Save As</button>
        <div class="zoom-controls" style="margin-left: 20px; display: flex; align-items: center; gap: 8px;">
            <button class="btn btn-secondary" id="zoomOutBtn" title="Zoom Out">🔍-</button>
            <button class="btn btn-secondary" id="resetZoomBtn" title="Reset Zoom">1:1</button>
            <button class="btn btn-secondary" id="zoomInBtn" title="Zoom In">🔍+</button>
            <span id="zoomLevel" style="font-size: 12px; color: #666; min-width: 40px; text-align: center;">100%</span>
        </div>
        <div style="margin-left: auto; display: flex; gap: 12px;">
            <button class="btn btn-secondary" id="addNodeBtn">Add Node</button>
        </div>
    </div>

    <div class="canvas-container">
        <div class="canvas" id="canvas">
            <svg id="connections" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
            </svg>
        </div>
    </div>

    <div class="status-bar">
        <span id="statusText">Ready - Configuration loaded automatically</span>
    </div>

    <!-- Node Edit Modal -->
    <div class="modal hidden" id="editModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title" id="modalTitle">Edit Node</h2>
            </div>
            <div id="modalForm">
                <!-- Form fields will be generated here -->
            </div>
            <div class="form-actions">
                <button class="btn btn-secondary" id="cancelBtn">Cancel</button>
                <button class="btn" id="saveNodeBtn">Save</button>
                <button class="btn btn-danger" id="deleteNodeBtn" style="margin-left: auto;">Delete</button>
            </div>
        </div>
    </div>

    <!-- Error Display Modal -->
    <div class="modal hidden" id="errorModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Error</h2>
            </div>
            <div id="errorMessage" style="padding: 20px; color: #e74c3c; white-space: pre-wrap;"></div>
            <div class="form-actions">
                <button class="btn" id="errorOkBtn">OK</button>
            </div>
        </div>
    </div>

    <!-- Add Node Modal -->
    <div class="modal hidden" id="addNodeModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Add New Node</h2>
            </div>
            <div style="padding: 20px;">
                <div class="form-group">
                    <label class="form-label">Node ID:</label>
                    <input class="form-input" id="newNodeId" type="text" placeholder="Enter unique node ID">
                </div>
                <div class="form-group">
                    <label class="form-label">Node Type:</label>
                    <select class="form-input" id="newNodeType">
                        <option value="">Select node type...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Description:</label>
                    <div id="nodeTypeDescription" style="font-size: 14px; color: #666; margin-top: 8px;"></div>
                </div>
            </div>
            <div class="form-actions">
                <button class="btn btn-secondary" id="addNodeCancelBtn">Cancel</button>
                <button class="btn" id="addNodeConfirmBtn">Add Node</button>
            </div>
        </div>
    </div>

    <!-- Template View -->
    <div class="template-view hidden" id="templateView">
        <div class="template-header">
            <div class="template-breadcrumb">
                <span id="templateBreadcrumb">Overview > Template: [Template Name]</span>
            </div>
            <div class="template-actions">
                <button class="btn btn-secondary" id="exitTemplateBtn">← Back to Overview</button>
                <button class="btn btn-primary" id="addTemplateNodeBtn">Add Node</button>
                <button class="btn" id="saveTemplateBtn">Save Template</button>
            </div>
        </div>
        <div class="template-content">
            <div class="template-sidebar">
                <h3>Template Variables</h3>
                <div id="templateVariables">
                    <!-- Variables will be populated here -->
                </div>
                <h3>Instances</h3>
                <div id="templateInstances">
                    <!-- Instances will be populated here -->
                </div>
                <button class="btn" id="addInstanceBtn">Add Instance</button>
            </div>
            <div class="template-canvas-container">
                <div class="template-canvas" id="templateCanvas">
                    <svg id="templateConnections" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></svg>
                </div>
            </div>
        </div>
    </div>

    <script>
        class ConfigurationEditor {
            constructor() {
                this.nodes = new Map();
                this.connections = [];
                this.selectedNode = null;
                this.dragOffset = { x: 0, y: 0 };
                this.isDragging = false;
                this.canvasOffset = { x: 0, y: 0 };
                this.currentConfig = null;
                this.nodeSchemas = null;

                // Zoom and pan properties
                this.scale = 1.0;
                this.minScale = 0.1;
                this.maxScale = 3.0;
                this.isPanning = false;
                this.panStart = { x: 0, y: 0 };

                // Template view properties
                this.isInTemplateView = false;
                this.currentTemplateNodeId = null;
                this.templateNodes = new Map();
                this.templateConnections = [];
                this.templateCanvasOffset = { x: 0, y: 0 };
                this.templateScale = 1.0;
                this.templateIsPanning = false;
                this.templatePanStart = { x: 0, y: 0 };

                this.initializeElements();
                this.setupEventListeners();
                this.loadNodeSchemas().then(() => {
                    this.loadInitialConfiguration();
                });
            }

            initializeElements() {
                this.canvas = document.getElementById('canvas');
                this.connectionsContainer = document.getElementById('connections');
                this.statusText = document.getElementById('statusText');
                this.editModal = document.getElementById('editModal');
                this.modalTitle = document.getElementById('modalTitle');
                this.modalForm = document.getElementById('modalForm');
                this.errorModal = document.getElementById('errorModal');
                this.errorMessage = document.getElementById('errorMessage');
                this.addNodeModal = document.getElementById('addNodeModal');

                // Template view elements
                this.templateView = document.getElementById('templateView');
                this.templateBreadcrumb = document.getElementById('templateBreadcrumb');
                this.templateCanvas = document.getElementById('templateCanvas');
                this.templateConnections = document.getElementById('templateConnections');
                this.templateVariables = document.getElementById('templateVariables');
                this.templateInstances = document.getElementById('templateInstances');
            }

            setupEventListeners() {
                // Toolbar buttons
                document.getElementById('loadBtn').addEventListener('click', () => this.loadConfiguration());
                document.getElementById('saveBtn').addEventListener('click', () => this.saveConfiguration());
                document.getElementById('saveAsBtn').addEventListener('click', () => this.saveAsConfiguration());
                document.getElementById('addNodeBtn').addEventListener('click', () => this.showAddNodeModal());
                
                // Zoom control buttons
                document.getElementById('zoomInBtn').addEventListener('click', () => this.zoomIn());
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.zoomOut());
                document.getElementById('resetZoomBtn').addEventListener('click', () => this.resetZoom());

                // Modal buttons
                document.getElementById('cancelBtn').addEventListener('click', () => this.closeModal());
                document.getElementById('saveNodeBtn').addEventListener('click', () => this.saveNodeChanges());
                document.getElementById('deleteNodeBtn').addEventListener('click', () => this.deleteNode());
                document.getElementById('errorOkBtn').addEventListener('click', () => this.closeErrorModal());
                document.getElementById('addNodeCancelBtn').addEventListener('click', () => this.closeAddNodeModal());
                document.getElementById('addNodeConfirmBtn').addEventListener('click', () => this.confirmAddNode());

                // Node type selection
                document.getElementById('newNodeType').addEventListener('change', (e) => this.updateNodeTypeDescription(e.target.value));

                // Template view buttons
                document.getElementById('exitTemplateBtn').addEventListener('click', () => this.exitTemplateView());
                document.getElementById('saveTemplateBtn').addEventListener('click', () => this.saveTemplate());
                document.getElementById('addTemplateNodeBtn').addEventListener('click', () => this.showAddTemplateNodeModal());
                document.getElementById('addInstanceBtn').addEventListener('click', () => this.addTemplateInstance());

                // Canvas events (both main and template)
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
                
                // Also add wheel listener to canvas container for better coverage
                const canvasContainer = document.querySelector('.canvas-container');
                if (canvasContainer) {
                    canvasContainer.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
                    canvasContainer.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                }
                
                document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                document.addEventListener('mouseup', (e) => this.handleMouseUp(e));

                // Prevent context menu
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Template canvas events
                this.templateCanvas = document.getElementById('templateCanvas');
                this.templateCanvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.templateCanvas.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
                this.templateCanvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Also add wheel listener to template canvas container for better coverage
                const templateCanvasContainer = document.querySelector('.template-canvas-container');
                if (templateCanvasContainer) {
                    templateCanvasContainer.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
                    templateCanvasContainer.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                }
            }

            async loadNodeSchemas() {
                try {
                    const response = await fetch('/api/node-schema');
                    if (response.ok) {
                        const data = await response.json();
                        this.nodeSchemas = data.schemas;
                        this.populateNodeTypeSelector();
                    } else {
                        console.error('Failed to load node schemas');
                    }
                } catch (error) {
                    console.error('Error loading node schemas:', error);
                }
            }

            populateNodeTypeSelector() {
                const selector = document.getElementById('newNodeType');
                selector.innerHTML = '<option value="">Select node type...</option>';
                
                if (this.nodeSchemas) {
                    Object.entries(this.nodeSchemas).forEach(([type, schema]) => {
                        const option = document.createElement('option');
                        option.value = type;
                        option.textContent = `${schema.icon} ${schema.name}`;
                        selector.appendChild(option);
                    });
                }
            }

            updateNodeTypeDescription(nodeType) {
                const descElement = document.getElementById('nodeTypeDescription');
                if (nodeType && this.nodeSchemas && this.nodeSchemas[nodeType]) {
                    descElement.textContent = this.nodeSchemas[nodeType].description;
                } else {
                    descElement.textContent = '';
                }
            }

            showError(message) {
                this.errorMessage.textContent = message;
                this.errorModal.classList.remove('hidden');
            }

            closeErrorModal() {
                this.errorModal.classList.add('hidden');
            }

            showAddNodeModal() {
                document.getElementById('newNodeId').value = '';
                document.getElementById('newNodeType').value = '';
                this.updateNodeTypeDescription('');
                this.addNodeModal.classList.remove('hidden');
            }

            closeAddNodeModal() {
                this.addNodeModal.classList.add('hidden');
            }

            confirmAddNode() {
                const nodeId = document.getElementById('newNodeId').value.trim();
                const nodeType = document.getElementById('newNodeType').value;
                
                if (!nodeId) {
                    this.showError('Please enter a node ID');
                    return;
                }
                
                if (!nodeType) {
                    this.showError('Please select a node type');
                    return;
                }
                
                if (this.nodes.has(nodeId)) {
                    this.showError('Node ID already exists!');
                    return;
                }

                this.createNewNode(nodeId, nodeType);
                this.closeAddNodeModal();
            }

            createNewNode(nodeId, nodeType) {
                if (!this.nodeSchemas || !this.nodeSchemas[nodeType]) {
                    this.showError('Invalid node type');
                    return;
                }

                const schema = this.nodeSchemas[nodeType];
                const nodeData = { type: nodeType };

                // Set default values for properties
                Object.entries(schema.properties).forEach(([prop, config]) => {
                    if (config.default !== undefined) {
                        nodeData[prop] = config.default;
                    }
                });

                // Find position for new node
                const existingNodes = Array.from(this.nodes.values());
                const x = 50 + (existingNodes.length % 4) * 220;
                const y = 50 + Math.floor(existingNodes.length / 4) * 180;

                this.createNode(nodeId, nodeData, x, y);
                this.updateConnections();
                this.statusText.textContent = `Added new ${schema.name} node: ${nodeId}`;
            }

            async loadInitialConfiguration() {
                try {
                    const response = await fetch('/api/load');
                    if (response.ok) {
                        const config = await response.json();
                        this.displayConfiguration(config);
                        this.statusText.textContent = `Loaded: ${config.filename || 'configuration'}`;
                    } else {
                        this.statusText.textContent = 'No configuration loaded - use Load button';
                    }
                } catch (error) {
                    console.error('Failed to load initial configuration:', error);
                    this.statusText.textContent = 'Failed to load initial configuration';
                }
            }

            async loadConfiguration() {
                try {
                    const response = await fetch('/api/load');
                    if (response.ok) {
                        const config = await response.json();
                        this.displayConfiguration(config);
                        this.statusText.textContent = `Loaded: ${config.filename || 'configuration'}`;
                    } else {
                        this.statusText.textContent = 'Failed to load configuration';
                    }
                } catch (error) {
                    console.error('Failed to load configuration:', error);
                    this.statusText.textContent = 'Error loading configuration';
                }
            }

            async saveConfiguration() {
                try {
                    const config = this.serializeConfiguration();
                    const response = await fetch('/api/save', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(config)
                    });
                    
                    if (response.ok) {
                        this.statusText.textContent = 'Configuration saved successfully';
                    } else {
                        const errorData = await response.json();
                        this.showError(errorData.error || 'Failed to save configuration');
                        this.statusText.textContent = 'Failed to save configuration';
                    }
                } catch (error) {
                    console.error('Failed to save configuration:', error);
                    this.showError('Error saving configuration: ' + error.message);
                    this.statusText.textContent = 'Error saving configuration';
                }
            }

            async saveAsConfiguration() {
                const filename = prompt('Enter filename (without .yaml extension):');
                if (!filename) return;

                try {
                    const config = this.serializeConfiguration();
                    const response = await fetch('/api/save-as', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ ...config, filename: filename + '.yaml' })
                    });
                    
                    if (response.ok) {
                        this.statusText.textContent = `Saved as: ${filename}.yaml`;
                    } else {
                        const errorData = await response.json();
                        this.showError(errorData.error || 'Failed to save configuration');
                        this.statusText.textContent = 'Failed to save configuration';
                    }
                } catch (error) {
                    console.error('Failed to save configuration:', error);
                    this.showError('Error saving configuration: ' + error.message);
                    this.statusText.textContent = 'Error saving configuration';
                }
            }

            displayConfiguration(config) {
                this.currentConfig = config;
                this.clearCanvas();

                const nodeEntries = Object.entries(config.data || {});
                const nodesPerRow = 4;
                const nodeSpacing = { x: 220, y: 180 };
                const startPos = { x: 50, y: 50 };

                nodeEntries.forEach(([nodeId, nodeData], index) => {
                    const row = Math.floor(index / nodesPerRow);
                    const col = index % nodesPerRow;
                    const x = startPos.x + col * nodeSpacing.x;
                    const y = startPos.y + row * nodeSpacing.y;

                    this.createNode(nodeId, nodeData, x, y);
                });

                this.updateConnections();
                this.updateZoomDisplay(); // Initialize zoom display
            }

            // Unified Node Rendering System
            // This system handles rendering for:
            // 1. Top-level nodes in overview
            // 2. Sub-graphs within template nodes (mini-graphs)
            // 3. Template editing view nodes

            createUnifiedNode(nodeId, nodeData, x, y, options = {}) {
                const {
                    isTemplateNode = false,
                    isReadOnly = false,
                    highlightPlaceholders = false,
                    scale = 1,
                    containerElement = this.canvas,
                    nodesMap = this.nodes
                } = options;

                const nodeElement = document.createElement('div');
                nodeElement.className = 'node';
                nodeElement.style.left = `${x}px`;
                nodeElement.style.top = `${y}px`;
                
                if (scale !== 1) {
                    nodeElement.style.transform = `scale(${scale})`;
                    nodeElement.style.transformOrigin = 'top left';
                }
                
                const nodeType = nodeData.type || 'unknown';
                nodeElement.classList.add(`node-type-${nodeType}`);

                const schema = this.nodeSchemas && this.nodeSchemas[nodeType];
                const icon = schema ? schema.icon : this.getNodeIcon(nodeType);
                const color = schema ? schema.color : this.getNodeColor(nodeType);
                
                // Set node color
                nodeElement.style.setProperty('--node-color', color);

                let content;
                if (nodeType === 'dynamic_template' && !isTemplateNode) {
                    // Dynamic template in overview - render with mini-graphs
                    content = this.formatDynamicTemplateNode(nodeId, nodeData, schema);
                } else {
                    // Regular node or template node
                    const properties = highlightPlaceholders 
                        ? this.formatTemplateNodeProperties(nodeData, schema)
                        : this.formatNodeProperties(nodeData, schema);
                    
                    const displayName = highlightPlaceholders 
                        ? this.highlightPlaceholders(nodeId)
                        : nodeId;
                    
                    content = `
                        <div class="node-header">
                            <div class="node-icon">${icon}</div>
                            <div class="node-name">${displayName}</div>
                        </div>
                        <div class="node-body">
                            ${properties}
                        </div>
                    `;
                }

                nodeElement.innerHTML = content;

                // Add event listeners only if not read-only
                if (!isReadOnly) {
                    if (isTemplateNode) {
                        nodeElement.addEventListener('dblclick', () => this.editTemplateNode(nodeId));
                        nodeElement.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.selectTemplateNode(nodeElement);
                        });
                    } else {
                        nodeElement.addEventListener('dblclick', () => this.editNode(nodeId));
                        nodeElement.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.selectNode(nodeElement);
                        });
                    }
                }

                containerElement.appendChild(nodeElement);
                nodesMap.set(nodeId, {
                    element: nodeElement,
                    data: { ...nodeData },
                    position: { x, y }
                });

                return nodeElement;
            }

            // Update existing methods to use unified renderer
            createNode(nodeId, nodeData, x, y) {
                return this.createUnifiedNode(nodeId, nodeData, x, y, {
                    isTemplateNode: false,
                    isReadOnly: false,
                    highlightPlaceholders: false
                });
            }

            createTemplateNode(nodeId, nodeData, x, y) {
                return this.createUnifiedNode(nodeId, nodeData, x, y, {
                    isTemplateNode: true,
                    isReadOnly: false,
                    highlightPlaceholders: true,
                    containerElement: this.templateCanvas,
                    nodesMap: this.templateNodes
                });
            }

            createMiniGraphNode(nodeId, nodeData, x, y, scale = 0.6) {
                const miniContainer = document.createElement('div');
                miniContainer.style.position = 'relative';
                miniContainer.style.display = 'inline-block';
                
                this.createUnifiedNode(nodeId, nodeData, x, y, {
                    isTemplateNode: false,
                    isReadOnly: true,
                    highlightPlaceholders: false,
                    scale: scale,
                    containerElement: miniContainer,
                    nodesMap: new Map() // Temporary map for mini-graph nodes
                });
                
                return miniContainer;
            }

            getNodeColor(nodeType) {
                const colors = {
                    'playlist': '#8E44AD',
                    'liked_tracks': '#E74C3C',
                    'output': '#2ECC71',
                    'combiner': '#F39C12',
                    'limit': '#34495E',
                    'sort': '#3498DB',
                    'filter_eval': '#E67E22',
                    'is_liked': '#E91E63',
                    'dedup': '#95A5A6'
                };
                return colors[nodeType] || '#7f8c8d';
            }

            getNodeIcon(nodeType) {
                const icons = {
                    'playlist': '♫',
                    'output': '📤',
                    'is_liked': '❤️',
                    'is_disliked': '💔',
                    'filter': '🔍',
                    'limit': '📊',
                    'shuffle': '🔀',
                    'sort': '📶'
                };
                return icons[nodeType] || '📦';
            }

            formatNodeProperties(nodeData, schema = null) {
                const excludeKeys = ['input', 'inputs', 'input_nodes', 'type'];
                const properties = Object.entries(nodeData)
                    .filter(([key]) => !excludeKeys.includes(key))
                    .slice(0, 4)
                    .map(([key, value]) => {
                        let displayValue = String(value);
                        if (displayValue.length > 25) {
                            displayValue = displayValue.substring(0, 22) + '...';
                        }
                        
                        // Use schema description if available
                        let keyDisplay = key;
                        if (schema && schema.properties && schema.properties[key]) {
                            const propSchema = schema.properties[key];
                            if (propSchema.description) {
                                keyDisplay = `${key}`;
                            }
                        }
                        
                        return `<div class="node-property"><strong>${keyDisplay}:</strong> ${displayValue}</div>`;
                    })
                    .join('');
                
                return properties || '<div class="node-property">No additional properties</div>';
            }

            formatDynamicTemplateNode(nodeId, nodeData, schema) {
                const icon = schema ? schema.icon : '🔄';
                const instances = nodeData.instances || [];
                const templateNodes = nodeData.template || {};
                
                // Calculate total layout dimensions
                const templateNodeCount = Object.keys(templateNodes).length;
                const instanceCount = instances.length;
                
                // Layout parameters for full-sized nodes
                const fullNodeWidth = 180;
                const fullNodeHeight = 80;
                const nodeSpacing = { x: 200, y: 100 };
                const instanceSpacing = { x: 50, y: 50 };
                
                // Calculate template node dimensions
                const nodesPerRow = Math.max(1, Math.min(4, templateNodeCount));
                const templateRows = Math.ceil(templateNodeCount / nodesPerRow);
                const templateWidth = nodesPerRow * fullNodeWidth + (nodesPerRow - 1) * nodeSpacing.x;
                const templateHeight = templateRows * fullNodeHeight + (templateRows - 1) * nodeSpacing.y;
                
                // Calculate overall dimensions
                const instanceRows = Math.ceil(instanceCount / 2);
                const totalWidth = Math.max(400, templateWidth + 100);
                const totalHeight = instanceRows * (templateHeight + instanceSpacing.y) + 100;
                
                // Generate all resolved instances
                const resolvedInstances = this.generateResolvedInstances(templateNodes, instances);
                
                return `
                    <div class="node-header">
                        <div class="node-icon">${icon}</div>
                        <div class="node-name">${nodeId}</div>
                    </div>
                    <div class="node-body" style="width: ${totalWidth}px; height: ${totalHeight}px; position: relative;">
                        <div class="node-property"><strong>Template:</strong> ${templateNodeCount} nodes</div>
                        <div class="node-property"><strong>Instances:</strong> ${instanceCount}</div>
                        <div class="template-instances-container" style="margin-top: 16px; position: relative;">
                            ${this.renderAllTemplateInstances(resolvedInstances, nodeId, totalWidth)}
                        </div>
                        <div style="margin-top: 12px; font-size: 11px; color: #007acc; font-style: italic; text-align: center;">
                            Double-click to edit template
                        </div>
                    </div>
                `;
            }

            generateResolvedInstances(templateNodes, instances) {
                const resolved = [];
                
                instances.forEach((instance, instanceIndex) => {
                    const resolvedNodes = {};
                    
                    // Resolve each template node for this instance
                    Object.entries(templateNodes).forEach(([templateNodeId, templateNodeData]) => {
                        // Replace variables in node ID
                        let resolvedId = templateNodeId;
                        Object.entries(instance).forEach(([variable, value]) => {
                            const placeholder = `{${variable}}`;
                            resolvedId = resolvedId.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), String(value));
                        });
                        
                        // Replace variables in node data
                        const resolvedData = this.resolveTemplateVariablesInObject(templateNodeData, instance);
                        
                        resolvedNodes[resolvedId] = {
                            ...resolvedData,
                            originalTemplateId: templateNodeId,
                            instanceIndex: instanceIndex
                        };
                    });
                    
                    resolved.push({
                        instance: instance,
                        instanceIndex: instanceIndex,
                        nodes: resolvedNodes
                    });
                });
                
                return resolved;
            }

            resolveTemplateVariablesInObject(obj, instance) {
                if (typeof obj === 'string') {
                    let resolved = obj;
                    Object.entries(instance).forEach(([variable, value]) => {
                        const placeholder = `{${variable}}`;
                        resolved = resolved.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), String(value));
                    });
                    return resolved;
                } else if (Array.isArray(obj)) {
                    return obj.map(item => this.resolveTemplateVariablesInObject(item, instance));
                } else if (obj !== null && typeof obj === 'object') {
                    const resolved = {};
                    Object.entries(obj).forEach(([key, value]) => {
                        resolved[key] = this.resolveTemplateVariablesInObject(value, instance);
                    });
                    return resolved;
                }
                return obj;
            }

            renderAllTemplateInstances(resolvedInstances, templateNodeId, totalWidth) {
                let html = '';
                let currentY = 0;
                
                resolvedInstances.forEach((resolvedInstance, index) => {
                    const instanceName = this.getInstanceDisplayName(resolvedInstance.instance);
                    const instanceHeight = this.calculateInstanceHeight(resolvedInstance.nodes);
                    
                    html += `
                        <div class="template-instance-full" style="position: absolute; top: ${currentY}px; left: 0; width: 100%; border: 2px solid #dee2e6; border-radius: 8px; background: #f8f9fa; padding: 12px; margin-bottom: 20px;">
                            <div style="font-weight: bold; margin-bottom: 12px; font-size: 12px; color: #495057; text-align: center; border-bottom: 1px solid #dee2e6; padding-bottom: 8px;">
                                Instance ${index + 1}: ${instanceName}
                            </div>
                            <div style="position: relative; min-height: ${instanceHeight}px;">
                                ${this.renderInstanceNodes(resolvedInstance.nodes, resolvedInstance.instanceIndex, templateNodeId)}
                            </div>
                        </div>
                    `;
                    
                    currentY += instanceHeight + 40; // Add spacing between instances
                });
                
                return html;
            }

            calculateInstanceHeight(nodes) {
                const nodeCount = Object.keys(nodes).length;
                const nodesPerRow = Math.min(3, nodeCount);
                const rows = Math.ceil(nodeCount / nodesPerRow);
                return rows * 100 + Math.max(0, rows - 1) * 20 + 40; // Base height + spacing + padding
            }

            renderInstanceNodes(nodes, instanceIndex, templateNodeId) {
                let html = '';
                let svgConnections = '';
                const nodePositions = {};
                
                // Layout nodes in a grid
                const nodeEntries = Object.entries(nodes);
                const nodesPerRow = Math.min(3, nodeEntries.length);
                const nodeWidth = 160;
                const nodeHeight = 80;
                const spacing = { x: 180, y: 100 };
                
                // Render nodes
                nodeEntries.forEach(([nodeId, nodeData], index) => {
                    const row = Math.floor(index / nodesPerRow);
                    const col = index % nodesPerRow;
                    const x = col * spacing.x + 10;
                    const y = row * spacing.y + 10;
                    
                    nodePositions[nodeId] = { x: x + nodeWidth/2, y: y + nodeHeight/2 };
                    
                    const nodeType = nodeData.type || 'unknown';
                    const schema = this.nodeSchemas && this.nodeSchemas[nodeType];
                    const nodeColor = schema ? schema.color : this.getNodeColor(nodeType);
                    const nodeIcon = schema ? schema.icon : this.getNodeIcon(nodeType);
                    
                    // Format properties for display
                    const properties = this.formatNodeProperties(nodeData, schema);
                    
                    html += `
                        <div class="template-instance-node" style="position: absolute; left: ${x}px; top: ${y}px; width: ${nodeWidth}px; height: ${nodeHeight}px; background: white; border: 2px solid ${nodeColor}; border-radius: 6px; padding: 8px; font-size: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 6px; padding-bottom: 4px; border-bottom: 1px solid #eee; background: ${nodeColor}; color: white; margin: -8px -8px 6px -8px; padding: 6px 8px; border-top-left-radius: 4px; border-top-right-radius: 4px;">
                                <span style="font-size: 12px;">${nodeIcon}</span>
                                <span style="font-weight: bold; font-size: 10px;">${nodeId}</span>
                            </div>
                            <div style="font-size: 9px; max-height: 45px; overflow: hidden;">
                                ${properties}
                            </div>
                        </div>
                    `;
                });
                
                // Generate connections between nodes
                nodeEntries.forEach(([nodeId, nodeData]) => {
                    const fromPos = nodePositions[nodeId];
                    if (!fromPos) return;
                    
                    // Check for input connections within the template
                    if (nodeData.input && nodePositions[nodeData.input]) {
                        const toPos = nodePositions[nodeData.input];
                        svgConnections += this.createSVGConnection(toPos, fromPos, 'internal');
                    }
                    
                    // Check for multiple inputs within the template
                    if (nodeData.inputs && Array.isArray(nodeData.inputs)) {
                        nodeData.inputs.forEach(inputId => {
                            if (inputId && nodePositions[inputId]) {
                                const toPos = nodePositions[inputId];
                                svgConnections += this.createSVGConnection(toPos, fromPos, 'internal');
                            }
                        });
                    }
                    
                    // Check for external connections (inputs from outside the template)
                    this.addExternalConnectionIndicators(nodeData, fromPos, instanceIndex, templateNodeId);
                });
                
                // Calculate SVG dimensions
                const maxX = Math.max(...Object.values(nodePositions).map(pos => pos.x)) + nodeWidth/2 + 20;
                const maxY = Math.max(...Object.values(nodePositions).map(pos => pos.y)) + nodeHeight/2 + 20;
                
                return `
                    ${html}
                    <svg style="position: absolute; top: 0; left: 0; width: ${maxX}px; height: ${maxY}px; pointer-events: none; z-index: 1;">
                        <defs>
                            <marker id="instance-arrow-${instanceIndex}" markerWidth="8" markerHeight="8" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L6,3 z" fill="#666"/>
                            </marker>
                            <marker id="external-arrow-${instanceIndex}" markerWidth="8" markerHeight="8" refX="6" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L6,3 z" fill="#e74c3c"/>
                            </marker>
                        </defs>
                        ${svgConnections}
                    </svg>
                `;
            }

            createSVGConnection(fromPos, toPos, type) {
                const markerType = type === 'external' ? 'external-arrow' : 'instance-arrow';
                const strokeColor = type === 'external' ? '#e74c3c' : '#666';
                const strokeWidth = type === 'external' ? '2' : '1.5';
                
                // Create curved connection
                const controlPoint1X = fromPos.x + (toPos.x - fromPos.x) * 0.5;
                const controlPoint1Y = fromPos.y;
                const controlPoint2X = toPos.x - (toPos.x - fromPos.x) * 0.5;
                const controlPoint2Y = toPos.y;
                
                return `
                    <path d="M ${fromPos.x} ${fromPos.y} C ${controlPoint1X} ${controlPoint1Y} ${controlPoint2X} ${controlPoint2Y} ${toPos.x} ${toPos.y}"
                          stroke="${strokeColor}" stroke-width="${strokeWidth}" fill="none" 
                          marker-end="url(#${markerType}-${Math.floor(Math.random() * 10000)})"/>
                `;
            }

            addExternalConnectionIndicators(nodeData, nodePos, instanceIndex, templateNodeId) {
                // This method would be used to show external connections
                // For now, we'll add visual indicators for external references
                const configData = this.currentConfig?.data || this.currentConfig || {};
                
                // Check if input references external nodes
                if (nodeData.input && !this.isTemplateInternalNode(nodeData.input, templateNodeId)) {
                    // Add external connection indicator - this could be enhanced further
                }
                
                if (nodeData.inputs && Array.isArray(nodeData.inputs)) {
                    nodeData.inputs.forEach(inputId => {
                        if (inputId && !this.isTemplateInternalNode(inputId, templateNodeId)) {
                            // Add external connection indicator
                        }
                    });
                }
            }

            isTemplateInternalNode(nodeId, templateNodeId) {
                // Check if the node ID corresponds to a template-internal node
                const configData = this.currentConfig?.data || this.currentConfig || {};
                const templateData = configData[templateNodeId];
                if (!templateData || !templateData.template) return false;
                
                // Check if it's a template node pattern
                return Object.keys(templateData.template).some(templateKey => {
                    // This is a simplified check - in practice, you'd need to resolve variables
                    return templateKey.includes('{') || nodeId.includes(templateKey.replace(/\{[^}]+\}/g, ''));
                });
            }

            getMiniNodeColor(nodeType) {
                const colors = {
                    'playlist': '#8E44AD',
                    'liked_tracks': '#E74C3C',
                    'all_tracks': '#9B59B6',
                    'output': '#2ECC71',
                    'combiner': '#F39C12',
                    'limit': '#34495E',
                    'sort': '#3498DB',
                    'filter_eval': '#E67E22',
                    'filter_time_added': '#16A085',
                    'filter_release_date': '#8E44AD',
                    'is_liked': '#E91E63',
                    'dedup': '#95A5A6',
                    'dynamic_template': '#17A2B8'
                };
                return colors[nodeType] || '#7f8c8d';
            }

            getMiniNodeIcon(nodeType) {
                const icons = {
                    'playlist': '♫',
                    'liked_tracks': '❤',
                    'all_tracks': '🎵',
                    'output': '📤',
                    'combiner': '➕',
                    'limit': '🔢',
                    'sort': '🔀',
                    'filter_eval': '🔍',
                    'filter_time_added': '⏰',
                    'filter_release_date': '📅',
                    'is_liked': '💖',
                    'dedup': '🎯',
                    'dynamic_template': '🔄'
                };
                return icons[nodeType] || '?';
            }

            getInstanceDisplayName(instance) {
                // Try to find a meaningful name from the instance variables
                const keys = Object.keys(instance);
                if (keys.length === 0) return 'Empty';
                
                // Look for common naming variables
                const nameKeys = ['name', 'title', 'label', 'id'];
                for (const key of nameKeys) {
                    if (instance[key]) return String(instance[key]).substring(0, 8);
                }
                
                // Use first variable value
                const firstValue = String(instance[keys[0]]);
                return firstValue.substring(0, 8) || 'Instance';
            }

            updateConnections() {
                this.connectionsContainer.innerHTML = '';
                this.connections = [];

                // Get current configuration data
                const configData = this.getCurrentConfigData();

                // First, create all internal connections (non-template nodes)
                for (const [nodeId, nodeInfo] of this.nodes) {
                    const nodeData = nodeInfo.data;
                    
                    // Skip dynamic template nodes - they'll be handled separately
                    if (nodeData.type === 'dynamic_template') continue;
                    
                    // Handle single input
                    if (nodeData.input) {
                        this.createConnectionLine(nodeData.input, nodeId, 'internal');
                    }
                    
                    // Handle multiple inputs
                    if (Array.isArray(nodeData.inputs)) {
                        nodeData.inputs.forEach(input => {
                            this.createConnectionLine(input, nodeId, 'internal');
                        });
                    }

                    // Handle input_nodes (used by combine_sort_dedup_output)
                    if (nodeData.input_nodes && Array.isArray(nodeData.input_nodes)) {
                        nodeData.input_nodes.forEach(inputId => {
                            if (inputId && this.nodes.has(inputId)) {
                                this.createConnection(inputId, nodeId);
                            }
                        });
                    }
                }

                // Then, handle template-related connections
                this.createTemplateConnections(configData);
            }

            createTemplateConnections(configData) {
                // Find all dynamic template nodes and their generated instances
                Object.entries(configData).forEach(([templateNodeId, templateNodeData]) => {
                    if (templateNodeData.type !== 'dynamic_template' || !templateNodeData.template || !templateNodeData.instances) {
                        return;
                    }

                    const templateNodes = templateNodeData.template;
                    const instances = templateNodeData.instances;

                    // For each instance, create resolved nodes and check for external connections
                    instances.forEach((instance, instanceIndex) => {
                        // Create mapping of template nodes to resolved names for this instance
                        const resolvedNodeIds = new Map();
                        
                        Object.keys(templateNodes).forEach(originalNodeId => {
                            let resolvedNodeId = originalNodeId;
                            Object.entries(instance).forEach(([variable, value]) => {
                                const placeholder = `{${variable}}`;
                                resolvedNodeId = resolvedNodeId.replace(
                                    new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), 
                                    String(value)
                                );
                            });
                            resolvedNodeIds.set(originalNodeId, resolvedNodeId);
                        });

                        // Check for external connections TO template-generated nodes
                        Object.entries(configData).forEach(([externalNodeId, externalNodeData]) => {
                            if (externalNodeData.type === 'dynamic_template') return;
                            
                            // Check if external node inputs reference template-generated nodes
                            const checkExternalInput = (inputId) => {
                                // Check if this input matches any resolved template node ID
                                for (const [originalId, resolvedId] of resolvedNodeIds) {
                                    if (inputId === resolvedId) {
                                        // External node references a template-generated node
                                        this.createExternalTemplateConnection(templateNodeId, externalNodeId, 'template-to-external');
                                        return true;
                                    }
                                }
                                return false;
                            };

                            // Check single input
                            if (externalNodeData.input) {
                                checkExternalInput(externalNodeData.input);
                            }
                            
                            // Check multiple inputs
                            if (Array.isArray(externalNodeData.inputs)) {
                                externalNodeData.inputs.forEach(checkExternalInput);
                            }
                            
                            // Check input_nodes (for combine_sort_dedup_output)
                            if (Array.isArray(externalNodeData.input_nodes)) {
                                externalNodeData.input_nodes.forEach(checkExternalInput);
                            }
                        });

                        // Check for external connections FROM template nodes (template nodes referencing external nodes)
                        Object.entries(templateNodes).forEach(([templateKey, templateNodeData]) => {
                            const checkTemplateInput = (inputId) => {
                                // Resolve the input ID with instance variables
                                let resolvedInputId = inputId;
                                Object.entries(instance).forEach(([variable, value]) => {
                                    const placeholder = `{${variable}}`;
                                    resolvedInputId = resolvedInputId.replace(
                                        new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), 
                                        String(value)
                                    );
                                });
                                
                                // Check if resolved input ID matches an external node
                                if (configData[resolvedInputId] && configData[resolvedInputId].type !== 'dynamic_template') {
                                    this.createExternalTemplateConnection(resolvedInputId, templateNodeId, 'external-to-template');
                                    return true;
                                }
                                return false;
                            };

                            if (templateNodeData.input) {
                                checkTemplateInput(templateNodeData.input);
                            }
                            if (Array.isArray(templateNodeData.inputs)) {
                                templateNodeData.inputs.forEach(checkTemplateInput);
                            }
                        });
                    });
                });
            }

            createExternalTemplateConnection(fromNodeId, toNodeId, connectionType) {
                const fromNode = this.nodes.get(fromNodeId);
                const toNode = this.nodes.get(toNodeId);
                
                if (!fromNode || !toNode) return;
                
                // Avoid duplicate connections
                const connectionKey = `${fromNodeId}-${toNodeId}-${connectionType}`;
                if (this.connections.some(c => c.key === connectionKey)) return;
                
                const fromRect = fromNode.element.getBoundingClientRect();
                const toRect = toNode.element.getBoundingClientRect();
                const canvasRect = this.canvas.getBoundingClientRect();
                
                // Calculate connection points
                let fromX, fromY, toX, toY;
                
                if (connectionType === 'external-to-template') {
                    // From external node to template node
                    fromX = fromRect.left - canvasRect.left + fromRect.width;
                    fromY = fromRect.top - canvasRect.top + fromRect.height / 2;
                    toX = toRect.left - canvasRect.left;
                    toY = toRect.top - canvasRect.top + toRect.height / 2;
                } else {
                    // From template node to external node
                    fromX = fromRect.left - canvasRect.left + fromRect.width;
                    fromY = fromRect.top - canvasRect.top + fromRect.height / 2;
                    toX = toRect.left - canvasRect.left;
                    toY = toRect.top - canvasRect.top + toRect.height / 2;
                }
                
                // Create the connection path with distinctive styling for external connections
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const d = `M${fromX},${fromY} L${toX},${toY}`;
                path.setAttribute('d', d);
                path.setAttribute('stroke', '#dc3545'); // Red for external connections
                path.setAttribute('stroke-width', '2');
                path.setAttribute('stroke-dasharray', '5,5'); // Dashed line for external connections
                path.setAttribute('fill', 'none');
                
                // Add arrow marker
                const markerId = `external-arrow-${fromNodeId}-${toNodeId}`;
                this.createArrowMarker(markerId, '#dc3545');
                path.setAttribute('marker-end', `url(#${markerId})`);
                
                this.connectionsContainer.appendChild(path);
                this.connections.push({ 
                    from: fromNodeId, 
                    to: toNodeId, 
                    element: path, 
                    key: connectionKey,
                    type: connectionType 
                });
            }

            createConnectionLine(fromNodeId, toNodeId, connectionType = 'internal') {
                const fromNode = this.nodes.get(fromNodeId);
                const toNode = this.nodes.get(toNodeId);
                
                if (!fromNode || !toNode) return;
                
                this.createConnection(fromNodeId, toNodeId);
            }

            createArrowMarker(markerId, color = '#6c757d') {
                let defs = this.connectionsContainer.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    this.connectionsContainer.appendChild(defs);
                }
                
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', markerId);
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '6');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '3');
                marker.setAttribute('orient', 'auto');
                marker.setAttribute('markerUnits', 'strokeWidth');
                
                const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                arrowPath.setAttribute('d', 'M0,0 L0,6 L9,3 z');
                arrowPath.setAttribute('fill', color);
                
                marker.appendChild(arrowPath);
                defs.appendChild(marker);
            }

            collectTemplateGeneratedNodes() {
                const templateNodes = new Map();
                const configData = this.currentConfig?.data || this.currentConfig || {};
                
                // Find all dynamic template nodes and their generated instances
                Object.entries(configData).forEach(([nodeId, nodeData]) => {
                    if (nodeData.type === 'dynamic_template' && nodeData.template && nodeData.instances) {
                        // For each instance, generate the resolved node IDs
                        nodeData.instances.forEach((instance, instanceIndex) => {
                            Object.keys(nodeData.template).forEach(templateNodeId => {
                                // Resolve template variables in the node ID
                                let resolvedNodeId = templateNodeId;
                                Object.entries(instance).forEach(([variable, value]) => {
                                    const placeholder = `{${variable}}`;
                                    resolvedNodeId = resolvedNodeId.replace(
                                        new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), 
                                        String(value)
                                    );
                                });
                                
                                templateNodes.set(resolvedNodeId, {
                                    templateNodeId: nodeId,
                                    instanceIndex: instanceIndex,
                                    originalTemplateKey: templateNodeId
                                });
                            });
                        });
                    }
                });
                
                return templateNodes;
            }

            createTemplateConnection(fromNodeId, toNodeId, templateGeneratedNodes) {
                const templateInfo = templateGeneratedNodes.get(fromNodeId);
                if (!templateInfo) return;
                
                // Find the template node element
                const templateNode = this.nodes.get(templateInfo.templateNodeId);
                if (!templateNode) return;
                
                const toNode = this.nodes.get(toNodeId);
                if (!toNode) return;
                
                // Get the positions
                const templateRect = templateNode.element.getBoundingClientRect();
                const toRect = toNode.element.getBoundingClientRect();
                const canvasRect = this.canvas.getBoundingClientRect();
                
                // Calculate connection points - from template node edge to target node
                const fromX = templateRect.left - canvasRect.left + templateRect.width;
                const fromY = templateRect.top - canvasRect.top + templateRect.height / 2;
                const toX = toRect.left - canvasRect.left;
                const toY = toRect.top - canvasRect.top + toRect.height / 2;
                
                // Create the connection path
                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                const controlPoint1X = fromX + (toX - fromX) * 0.5;
                const controlPoint1Y = fromY;
                const controlPoint2X = toX - (toX - fromX) * 0.5;
                const controlPoint2Y = toY;
                
                const pathData = `M ${fromX} ${fromY} C ${controlPoint1X} ${controlPoint1Y} ${controlPoint2X} ${controlPoint2Y} ${toX} ${toY}`;
                
                path.setAttribute("d", pathData);
                path.setAttribute("class", "connection-line template-connection");
                path.setAttribute("stroke", "#e74c3c"); // Different color for template connections
                path.setAttribute("stroke-width", "2");
                path.setAttribute("stroke-dasharray", "5,5"); // Dashed line to indicate template connection
                
                // Add arrow marker for template connections
                const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
                const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
                marker.setAttribute("id", `template-arrow-${fromNodeId}-${toNodeId}`);
                marker.setAttribute("markerWidth", "10");
                marker.setAttribute("markerHeight", "10");
                marker.setAttribute("refX", "8");
                marker.setAttribute("refY", "3");
                marker.setAttribute("orient", "auto");
                marker.setAttribute("markerUnits", "strokeWidth");
                
                const arrowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                arrowPath.setAttribute("d", "M0,0 L0,6 L9,3 z");
                arrowPath.setAttribute("fill", "#e74c3c");
                
                marker.appendChild(arrowPath);
                defs.appendChild(marker);
                this.connectionsContainer.appendChild(defs);
                
                path.setAttribute("marker-end", `url(#template-arrow-${fromNodeId}-${toNodeId})`);
                this.connectionsContainer.appendChild(path);
                
                this.connections.push({ from: fromNodeId, to: toNodeId, element: path, type: 'template' });
            }

            createConnection(fromNodeId, toNodeId) {
                const fromNode = this.nodes.get(fromNodeId);
                const toNode = this.nodes.get(toNodeId);
                
                if (!fromNode || !toNode) return;

                // Since the SVG is inside the canvas and transforms with it, 
                // we can use the node positions and sizes directly from their styles
                const fromLeft = parseFloat(fromNode.element.style.left) || 0;
                const fromTop = parseFloat(fromNode.element.style.top) || 0;
                const toLeft = parseFloat(toNode.element.style.left) || 0;
                const toTop = parseFloat(toNode.element.style.top) || 0;
                
                // Use standard node dimensions (most nodes are similar size)
                const nodeWidth = 180; // Standard node width
                const nodeHeight = 80;  // Approximate node height
                
                // Calculate center points
                const fromX = fromLeft + nodeWidth / 2;
                const fromY = fromTop + nodeHeight / 2;
                const toX = toLeft + nodeWidth / 2;
                const toY = toTop + nodeHeight / 2;

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                const controlPoint1X = fromX + (toX - fromX) * 0.5;
                const controlPoint1Y = fromY;
                const controlPoint2X = toX - (toX - fromX) * 0.5;
                const controlPoint2Y = toY;

                const pathData = `M ${fromX} ${fromY} C ${controlPoint1X} ${controlPoint1Y} ${controlPoint2X} ${controlPoint2Y} ${toX} ${toY}`;
                
                path.setAttribute("d", pathData);
                path.setAttribute("class", "connection-line");

                // Add arrow marker
                const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
                const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
                marker.setAttribute("id", `arrow-${fromNodeId}-${toNodeId}`);
                marker.setAttribute("markerWidth", "10");
                marker.setAttribute("markerHeight", "10");
                marker.setAttribute("refX", "8");
                marker.setAttribute("refY", "3");
                marker.setAttribute("orient", "auto");
                marker.setAttribute("markerUnits", "strokeWidth");

                const arrowPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                arrowPath.setAttribute("d", "M0,0 L0,6 L9,3 z");
                arrowPath.setAttribute("class", "connection-arrow");

                marker.appendChild(arrowPath);
                defs.appendChild(marker);
                this.connectionsContainer.appendChild(defs);

                path.setAttribute("marker-end", `url(#arrow-${fromNodeId}-${toNodeId})`);
                this.connectionsContainer.appendChild(path);

                this.connections.push({ from: fromNodeId, to: toNodeId, element: path });
            }

            selectNode(nodeElement) {
                // Remove previous selection
                this.nodes.forEach(nodeInfo => {
                    nodeInfo.element.classList.remove('selected');
                });

                // Select new node
                nodeElement.classList.add('selected');
                this.selectedNode = nodeElement;
            }

            editNode(nodeId) {
                const nodeInfo = this.nodes.get(nodeId);
                if (!nodeInfo) return;

                // Special handling for dynamic templates - enter template view instead of editing
                if (nodeInfo.data.type === 'dynamic_template') {
                    this.enterTemplateView(nodeId);
                    return;
                }

                this.modalTitle.textContent = `Edit Node: ${nodeId}`;
                this.currentEditingNode = nodeId;
                
                const nodeType = nodeInfo.data.type;
                const schema = this.nodeSchemas && this.nodeSchemas[nodeType];
                
                // Generate form fields based on schema
                this.modalForm.innerHTML = '';
                
                if (schema) {
                    // Add type field (read-only)
                    const typeGroup = document.createElement('div');
                    typeGroup.className = 'form-group';
                    typeGroup.innerHTML = `
                        <label class="form-label">Type:</label>
                        <input class="form-input" value="${schema.icon} ${schema.name}" readonly style="background: #f5f5f5; color: #666;">
                    `;
                    this.modalForm.appendChild(typeGroup);

                    // Add schema-defined properties
                    Object.entries(schema.properties).forEach(([propName, propConfig]) => {
                        const currentValue = nodeInfo.data[propName] || '';
                        const formGroup = this.createPropertyInput(propName, propConfig, currentValue, nodeId);
                        this.modalForm.appendChild(formGroup);
                    });

                    // Add existing properties not in schema (for backwards compatibility)
                    Object.entries(nodeInfo.data).forEach(([key, value]) => {
                        if (key !== 'type' && !schema.properties[key] && key !== 'input' && key !== 'inputs') {
                            const formGroup = document.createElement('div');
                            formGroup.className = 'form-group';
                            formGroup.innerHTML = `
                                <label class="form-label">${key}: <small style="color: #e67e22;">(custom property)</small></label>
                                <input class="form-input" name="${key}" value="${value || ''}" type="text">
                            `;
                            this.modalForm.appendChild(formGroup);
                        }
                    });
                } else {
                    // Fallback for unknown node types
                    Object.entries(nodeInfo.data).forEach(([key, value]) => {
                        if (key === 'input' || key === 'inputs') return;

                        const formGroup = document.createElement('div');
                        formGroup.className = 'form-group';
                        
                        const isReadonly = key === 'type' ? 'readonly style="background: #f5f5f5; color: #666;"' : '';
                        formGroup.innerHTML = `
                            <label class="form-label">${key}:</label>
                            <input class="form-input" name="${key}" value="${value || ''}" type="text" ${isReadonly}>
                        `;
                        
                        this.modalForm.appendChild(formGroup);
                    });
                }

                this.editModal.classList.remove('hidden');
            }

            createPropertyInput(propName, propConfig, currentValue, nodeId) {
                const formGroup = document.createElement('div');
                formGroup.className = 'form-group';
                
                const isRequired = propConfig.required ? ' <span style="color: #e74c3c;">*</span>' : '';
                const description = propConfig.description ? `<br><small style="color: #666;">${propConfig.description}</small>` : '';
                
                let inputHtml = '';
                
                switch (propConfig.type) {
                    case 'boolean':
                        const checked = currentValue === true || currentValue === 'true' ? 'checked' : '';
                        inputHtml = `<input class="form-input" name="${propName}" type="checkbox" ${checked} style="width: auto;">`;
                        break;
                        
                    case 'integer':
                        inputHtml = `<input class="form-input" name="${propName}" value="${currentValue || ''}" type="number" step="1">`;
                        break;
                        
                    case 'select':
                        const options = propConfig.options || [];
                        const optionsHtml = options.map(option => {
                            const selected = option === currentValue ? 'selected' : '';
                            return `<option value="${option}" ${selected}>${option}</option>`;
                        }).join('');
                        inputHtml = `<select class="form-input" name="${propName}">
                            <option value="">Select ${propName}...</option>
                            ${optionsHtml}
                        </select>`;
                        break;
                        
                    case 'node_reference':
                        const nodeOptions = Array.from(this.nodes.keys()).filter(id => id !== nodeId);
                        const nodeOptionsHtml = nodeOptions.map(nodeId => {
                            const selected = nodeId === currentValue ? 'selected' : '';
                            return `<option value="${nodeId}" ${selected}>${nodeId}</option>`;
                        }).join('');
                        inputHtml = `<select class="form-input" name="${propName}">
                            <option value="">Select node...</option>
                            ${nodeOptionsHtml}
                        </select>`;
                        break;
                        
                    case 'node_list':
                        // Create multi-select checkbox interface for node lists
                        const availableNodes = Array.from(this.nodes.keys()).filter(id => id !== nodeId);
                        const currentValues = Array.isArray(currentValue) ? currentValue : (currentValue ? [currentValue] : []);
                        
                        if (availableNodes.length === 0) {
                            inputHtml = `<div class="checkbox-list">
                                <div class="checkbox-list-empty">No other nodes available</div>
                            </div>`;
                        } else {
                            const checkboxItems = availableNodes.map(nodeOption => {
                                const isChecked = currentValues.includes(nodeOption);
                                const checkboxId = `${propName}_${nodeOption}`;
                                return `<div class="checkbox-item">
                                    <input type="checkbox" id="${checkboxId}" name="${propName}" value="${nodeOption}" ${isChecked ? 'checked' : ''}>
                                    <label for="${checkboxId}">${nodeOption}</label>
                                </div>`;
                            }).join('');
                            
                            inputHtml = `<div class="checkbox-list" name="${propName}">
                                ${checkboxItems}
                            </div>`;
                        }
                        break;
                        
                    default: // text
                        inputHtml = `<input class="form-input" name="${propName}" value="${currentValue || ''}" type="text">`;
                        break;
                }
                
                formGroup.innerHTML = `
                    <label class="form-label">${propName}${isRequired}${description}</label>
                    ${inputHtml}
                `;
                
                return formGroup;
            }

            saveNodeChanges() {
                const nodeInfo = this.nodes.get(this.currentEditingNode);
                if (!nodeInfo) return;

                // First, collect all checkbox lists for node_list properties
                const checkboxLists = {};
                this.modalForm.querySelectorAll('.checkbox-list').forEach(checkboxContainer => {
                    const propertyName = checkboxContainer.getAttribute('name');
                    if (propertyName) {
                        const checkboxes = checkboxContainer.querySelectorAll('input[type="checkbox"]:checked');
                        checkboxLists[propertyName] = Array.from(checkboxes).map(cb => cb.value);
                    }
                });

                // Update properties from all form inputs
                const inputs = this.modalForm.querySelectorAll('input[name], select[name], textarea[name]');
                
                inputs.forEach(input => {
                    const propName = input.name;
                    
                    // Skip checkboxes that are part of checkbox lists (handled above)
                    if (input.type === 'checkbox' && input.closest('.checkbox-list')) {
                        return;
                    }
                    
                    let value = input.value.trim();
                    
                    // Handle different input types
                    if (input.type === 'checkbox') {
                        value = input.checked;
                    } else if (input.type === 'number') {
                        value = value ? parseInt(value) : '';
                    } else if (input.tagName === 'TEXTAREA' && propName === 'inputs') {
                        // Handle legacy node lists (fallback for textarea)
                        if (value) {
                            value = value.split(',').map(s => s.trim()).filter(s => s);
                        } else {
                            value = [];
                        }
                    }
                    
                    // Update the node data
                    if (value !== '') {
                        nodeInfo.data[propName] = value;
                    } else if (nodeInfo.data.hasOwnProperty(propName)) {
                        delete nodeInfo.data[propName];
                    }
                });
                
                // Apply checkbox list values
                Object.entries(checkboxLists).forEach(([propName, values]) => {
                    if (values.length > 0) {
                        nodeInfo.data[propName] = values;
                    } else if (nodeInfo.data.hasOwnProperty(propName)) {
                        delete nodeInfo.data[propName];
                    }
                });

                // Update the visual representation
                const nodeType = nodeInfo.data.type;
                const schema = this.nodeSchemas && this.nodeSchemas[nodeType];
                const properties = this.formatNodeProperties(nodeInfo.data, schema);
                const bodyElement = nodeInfo.element.querySelector('.node-body');
                bodyElement.innerHTML = properties;

                this.closeModal();
                this.statusText.textContent = `Updated node: ${this.currentEditingNode}`;
                
                // Update connections in case inputs changed
                this.updateConnections();
            }

            closeModal() {
                this.editModal.classList.add('hidden');
                this.currentEditingNode = null;
            }

            deleteNode() {
                if (!this.currentEditingNode) return;
                
                // Confirm deletion
                if (!confirm(`Are you sure you want to delete node "${this.currentEditingNode}"?`)) {
                    return;
                }
                
                const nodeId = this.currentEditingNode;
                const nodeInfo = this.nodes.get(nodeId);
                
                if (nodeInfo) {
                    // Remove the visual element
                    nodeInfo.element.remove();
                    
                    // Remove from nodes map
                    this.nodes.delete(nodeId);
                    
                    // Remove connections involving this node
                    this.connections = this.connections.filter(conn => {
                        if (conn.from === nodeId || conn.to === nodeId) {
                            // Remove the connection element
                            conn.element.remove();
                            return false;
                        }
                        return true;
                    });
                    
                    // Update all remaining nodes that might reference this deleted node
                    this.nodes.forEach((remainingNodeInfo, remainingNodeId) => {
                        const data = remainingNodeInfo.data;
                        
                        // Clean up single input references
                        if (data.input === nodeId) {
                            delete data.input;
                        }
                        
                        // Clean up multiple input references
                        if (data.inputs && Array.isArray(data.inputs)) {
                            data.inputs = data.inputs.filter(inputId => inputId !== nodeId);
                            if (data.inputs.length === 0) {
                                delete data.inputs;
                            }
                        }
                    });
                    
                    // Update connections to reflect the cleanup
                    this.updateConnections();
                    
                    // Close modal and update status
                    this.closeModal();
                    this.statusText.textContent = `Deleted node: ${nodeId}`;
                }
            }

            // Remove old addNewNode - replaced by showAddNodeModal

            clearCanvas() {
                this.canvas.innerHTML = '<svg id="connections" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></svg>';
                this.connectionsContainer = document.getElementById('connections');
                this.nodes.clear();
                this.connections = [];
            }

            serializeConfiguration() {
                const data = {};
                this.nodes.forEach((nodeInfo, nodeId) => {
                    data[nodeId] = { ...nodeInfo.data };
                });
                return { data };
            }

            // Template View Methods
            async enterTemplateView(nodeId) {
                try {
                    this.currentTemplateNodeId = nodeId;
                    
                    // Get the current configuration and ensure it includes the latest node data
                    const configData = this.getCurrentConfigData();
                    
                    const response = await fetch('/api/template/enter', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            nodeId: nodeId,
                            configData: configData
                        })
                    });

                    if (response.ok) {
                        const templateData = await response.json();
                        this.showTemplateView(nodeId, templateData);
                    } else {
                        const error = await response.json();
                        this.showError(`Failed to enter template: ${error.error}`);
                    }
                } catch (error) {
                    this.showError(`Error entering template: ${error.message}`);
                }
            }

            getCurrentConfigData() {
                // Start with existing configuration
                const baseConfig = this.currentConfig?.data || this.currentConfig || {};
                
                // Update with current node data to ensure newly created nodes are included
                const currentData = {};
                this.nodes.forEach((nodeInfo, nodeId) => {
                    currentData[nodeId] = { ...nodeInfo.data };
                });
                
                // Merge base configuration with current node data
                return { ...baseConfig, ...currentData };
            }

            showTemplateView(nodeId, templateData) {
                this.isInTemplateView = true;
                
                // Update breadcrumb
                this.templateBreadcrumb.textContent = `Overview > Template: ${nodeId}`;
                
                // Show template view and hide main view
                this.templateView.classList.remove('hidden');
                
                // Load template nodes
                this.loadTemplateNodes(templateData.templateNodes);
                
                // Show variables and instances
                this.displayTemplateVariables(templateData.variables);
                this.displayTemplateInstances(templateData.instances, templateData.variables);
                
                // Update zoom display for template view
                this.updateZoomDisplay();
            }

            loadTemplateNodes(templateNodes) {
                // Clear existing template canvas
                this.templateCanvas.innerHTML = '<svg id="templateConnections" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></svg>';
                this.templateConnections = document.getElementById('templateConnections');
                this.templateNodes.clear();

                // Create nodes with placeholder highlighting
                let x = 50, y = 50;
                for (const [nodeId, nodeData] of Object.entries(templateNodes)) {
                    this.createTemplateNode(nodeId, nodeData, x, y);
                    x += 200;
                    if (x > 800) {
                        x = 50;
                        y += 150;
                    }
                }

                this.updateTemplateConnections();
            }

            createTemplateNode(nodeId, nodeData, x, y) {
                // Use unified rendering system for template nodes
                const nodeElement = this.createUnifiedNode(nodeId, nodeData, x, y, {
                    isTemplateNode: true,
                    highlightPlaceholders: true,
                    containerElement: this.templateCanvas,
                    nodesMap: this.templateNodes
                });
                
                // Add delete button to all template nodes
                this.addDeleteButtonToNode(nodeElement, nodeId);
                
                return nodeElement;
            }

            formatTemplateNodeProperties(nodeData, schema) {
                let properties = '';
                
                for (const [key, value] of Object.entries(nodeData)) {
                    if (key === 'type') continue;
                    
                    const displayValue = this.highlightPlaceholders(String(value));
                    properties += `<div class="node-property"><strong>${key}:</strong> ${displayValue}</div>`;
                }
                
                return properties || '<div class="node-property"><em>No properties</em></div>';
            }

            highlightPlaceholders(text) {
                if (typeof text !== 'string') return text;
                return text.replace(/\{([^{}]+)\}/g, '<span class="template-placeholder">{$1}</span>');
            }

            displayTemplateVariables(variables) {
                this.templateVariables.innerHTML = '';
                
                if (variables.length === 0) {
                    this.templateVariables.innerHTML = '<div style="color: #666; font-style: italic;">No variables detected</div>';
                    return;
                }

                variables.forEach(variable => {
                    const varElement = document.createElement('div');
                    varElement.className = 'template-variable';
                    varElement.textContent = `{${variable}}`;
                    this.templateVariables.appendChild(varElement);
                });
            }

            displayTemplateInstances(instances, variables) {
                this.templateInstances.innerHTML = '';
                
                instances.forEach((instance, index) => {
                    const instanceElement = document.createElement('div');
                    instanceElement.className = 'template-instance';
                    
                    const header = document.createElement('div');
                    header.className = 'template-instance-header';
                    header.innerHTML = `
                        <span class="template-instance-title">Instance ${index + 1}</span>
                        <button class="template-instance-remove" onclick="editor.removeTemplateInstance(${index})">Remove</button>
                    `;
                    instanceElement.appendChild(header);

                    const varsContainer = document.createElement('div');
                    varsContainer.className = 'template-instance-vars';
                    
                    variables.forEach(variable => {
                        const varDiv = document.createElement('div');
                        varDiv.className = 'template-instance-var';
                        varDiv.innerHTML = `
                            <label>${variable}:</label>
                            <input type="text" value="${instance[variable] || ''}" 
                                   onchange="editor.updateInstanceVariable(${index}, '${variable}', this.value)">
                        `;
                        varsContainer.appendChild(varDiv);
                    });
                    
                    instanceElement.appendChild(varsContainer);
                    this.templateInstances.appendChild(instanceElement);
                });
            }

            updateTemplateConnections() {
                if (!this.templateConnections) return;
                
                this.templateConnections.innerHTML = '';
                
                // Get template node data for the current template
                const configData = this.getCurrentConfigData();
                const templateData = configData[this.currentTemplateNodeId];
                if (!templateData || !templateData.template) return;
                
                const templateNodes = templateData.template;
                
                // Use the same connection logic as main canvas but for template nodes
                for (const [nodeId, nodeData] of Object.entries(templateNodes)) {
                    // Handle single input
                    if (nodeData.input) {
                        this.createTemplateConnectionLine(nodeData.input, nodeId);
                    }
                    
                    // Handle multiple inputs
                    if (Array.isArray(nodeData.inputs)) {
                        nodeData.inputs.forEach(input => {
                            this.createTemplateConnectionLine(input, nodeId);
                        });
                    }
                }
            }

            createTemplateConnectionLine(fromNodeId, toNodeId) {
                const fromNode = this.templateNodes.get(fromNodeId);
                const toNode = this.templateNodes.get(toNodeId);
                
                if (!fromNode || !toNode) return;
                
                const fromRect = fromNode.element.getBoundingClientRect();
                const toRect = toNode.element.getBoundingClientRect();
                const canvasRect = this.templateCanvas.getBoundingClientRect();
                
                // Calculate connection points
                const fromX = fromRect.left - canvasRect.left + fromRect.width;
                const fromY = fromRect.top - canvasRect.top + fromRect.height / 2;
                const toX = toRect.left - canvasRect.left;
                const toY = toRect.top - canvasRect.top + toRect.height / 2;
                
                // Create the connection path
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const d = `M${fromX},${fromY} L${toX},${toY}`;
                path.setAttribute('d', d);
                path.setAttribute('stroke', '#6c757d');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                
                // Add arrow marker
                const markerId = `template-arrow-${fromNodeId}-${toNodeId}`;
                
                let defs = this.templateConnections.querySelector('defs');
                if (!defs) {
                    defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    this.templateConnections.appendChild(defs);
                }
                
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', markerId);
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '6');
                marker.setAttribute('refX', '9');
                marker.setAttribute('refY', '3');
                marker.setAttribute('orient', 'auto');
                marker.setAttribute('markerUnits', 'strokeWidth');
                
                const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                arrowPath.setAttribute('d', 'M0,0 L0,6 L9,3 z');
                arrowPath.setAttribute('fill', '#6c757d');
                
                marker.appendChild(arrowPath);
                defs.appendChild(marker);
                
                path.setAttribute('marker-end', `url(#${markerId})`);
                this.templateConnections.appendChild(path);
            }

            selectTemplateNode(nodeElement) {
                // Remove previous selection
                this.templateNodes.forEach(nodeInfo => {
                    nodeInfo.element.classList.remove('selected');
                });

                // Select new node
                nodeElement.classList.add('selected');
            }

            editTemplateNode(nodeId) {
                // Get the template node data
                const configData = this.currentConfig?.data || this.currentConfig || {};
                const templateData = configData[this.currentTemplateNodeId];
                if (!templateData || !templateData.template) return;
                
                const templateNodeData = templateData.template[nodeId];
                if (!templateNodeData) return;
                
                // Create a modal dialog for editing the template node
                this.showTemplateNodeEditModal(nodeId, templateNodeData);
            }

            showTemplateNodeEditModal(nodeId, nodeData) {
                // Create modal HTML
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.id = 'templateNodeEditModal';
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2 class="modal-title">Edit Template Node: ${nodeId}</h2>
                        </div>
                        <div id="templateNodeForm">
                            ${this.generateTemplateNodeForm(nodeData)}
                        </div>
                        <div class="form-actions">
                            <button class="btn btn-secondary" id="cancelTemplateNodeBtn">Cancel</button>
                            <button class="btn" id="saveTemplateNodeBtn">Save</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Add event listeners
                document.getElementById('cancelTemplateNodeBtn').addEventListener('click', () => {
                    this.closeTemplateNodeEditModal();
                });
                
                document.getElementById('saveTemplateNodeBtn').addEventListener('click', () => {
                    this.saveTemplateNodeChanges(nodeId);
                });
                
                // Store current editing context
                this.currentEditingTemplateNode = nodeId;
                this.currentEditingTemplateNodeData = { ...nodeData };
            }

            generateTemplateNodeForm(nodeData) {
                let html = '';
                
                // Add type field (read-only for now, but could be made editable)
                html += `
                    <div class="form-group">
                        <label class="form-label">Type:</label>
                        <select class="form-input" name="type" onchange="editor.onTemplateNodeTypeChange(this.value)">
                `;
                
                // Populate node type options
                if (this.nodeSchemas) {
                    Object.entries(this.nodeSchemas).forEach(([type, schema]) => {
                        const selected = nodeData.type === type ? 'selected' : '';
                        html += `<option value="${type}" ${selected}>${schema.icon} ${schema.name}</option>`;
                    });
                }
                
                html += `
                        </select>
                    </div>
                `;
                
                // Add property fields based on the node type and current data
                Object.entries(nodeData).forEach(([key, value]) => {
                    if (key === 'type') return; // Already handled above
                    
                    const isArray = Array.isArray(value);
                    const displayValue = isArray ? value.join(', ') : String(value);
                    
                    html += `
                        <div class="form-group">
                            <label class="form-label">${key}:</label>
                            ${isArray ? 
                                `<input class="form-input" name="${key}" value="${displayValue}" type="text" placeholder="Comma-separated values">` :
                                `<input class="form-input" name="${key}" value="${displayValue}" type="text">`
                            }
                        </div>
                    `;
                });
                
                // Add button to add new properties
                html += `
                    <div class="form-group">
                        <button type="button" class="btn btn-secondary" onclick="editor.addTemplateNodeProperty()">Add Property</button>
                    </div>
                `;
                
                return html;
            }

            onTemplateNodeTypeChange(newType) {
                // Update the form fields based on the new node type
                const schema = this.nodeSchemas && this.nodeSchemas[newType];
                if (schema) {
                    // Could add logic here to update form fields based on schema
                    // For now, just update the type
                    this.currentEditingTemplateNodeData.type = newType;
                }
            }

            addTemplateNodeProperty() {
                const form = document.getElementById('templateNodeForm');
                const newPropertyDiv = document.createElement('div');
                newPropertyDiv.className = 'form-group';
                newPropertyDiv.innerHTML = `
                    <label class="form-label">
                        <input type="text" class="form-input" placeholder="Property name" style="width: 120px; margin-right: 8px;">
                    </label>
                    <input class="form-input" type="text" placeholder="Property value" style="width: 200px;">
                    <button type="button" class="btn btn-secondary" onclick="this.parentElement.remove()" style="margin-left: 8px;">Remove</button>
                `;
                
                // Insert before the "Add Property" button
                const addButton = form.querySelector('button[onclick*="addTemplateNodeProperty"]').parentElement;
                form.insertBefore(newPropertyDiv, addButton);
            }

            saveTemplateNodeChanges(nodeId) {
                const form = document.getElementById('templateNodeForm');
                const formData = new FormData(form);
                const updatedData = {};
                
                // Get all form inputs
                const inputs = form.querySelectorAll('input, select');
                inputs.forEach(input => {
                    if (input.name) {
                        let value = input.value;
                        
                        // Handle array values (comma-separated)
                        if (input.placeholder && input.placeholder.includes('Comma-separated')) {
                            value = value.split(',').map(v => v.trim()).filter(v => v);
                        }
                        
                        updatedData[input.name] = value;
                    }
                });
                
                // Handle custom properties
                const customGroups = form.querySelectorAll('.form-group');
                customGroups.forEach(group => {
                    const nameInput = group.querySelector('input[placeholder="Property name"]');
                    const valueInput = group.querySelector('input[placeholder="Property value"]');
                    if (nameInput && valueInput && nameInput.value && valueInput.value) {
                        updatedData[nameInput.value] = valueInput.value;
                    }
                });
                
                // Update the template node data
                const configData = this.currentConfig?.data || this.currentConfig || {};
                const templateData = configData[this.currentTemplateNodeId];
                if (templateData && templateData.template) {
                    templateData.template[nodeId] = updatedData;
                    
                    // Refresh the template view
                    this.enterTemplateView(this.currentTemplateNodeId);
                }
                
                this.closeTemplateNodeEditModal();
            }

            closeTemplateNodeEditModal() {
                const modal = document.getElementById('templateNodeEditModal');
                if (modal) {
                    modal.remove();
                }
                this.currentEditingTemplateNode = null;
                this.currentEditingTemplateNodeData = null;
            }

            exitTemplateView() {
                this.isInTemplateView = false;
                this.currentTemplateNodeId = null;
                this.templateView.classList.add('hidden');
                
                // Update zoom display for main view
                this.updateZoomDisplay();
            }

            saveTemplate() {
                // Save current template changes
                const configData = this.getCurrentConfigData();
                const templateData = configData[this.currentTemplateNodeId];
                if (!templateData) return;
                
                // Update the main node data with any changes
                const nodeInfo = this.nodes.get(this.currentTemplateNodeId);
                if (nodeInfo) {
                    nodeInfo.data = { ...templateData };
                }
                
                // Mark as modified
                this.isModified = true;
                this.updateStatus('Template saved locally. Use "Save" to persist changes.');
                
                // Update connections to reflect any changes
                this.updateConnections();
                
                // Return to overview
                this.exitTemplateView();
            }

            addTemplateInstance() {
                // Add a new empty instance
                const configData = this.getCurrentConfigData();
                const nodeData = configData[this.currentTemplateNodeId];
                if (!nodeData.instances) nodeData.instances = [];
                
                // Create new instance with empty values for all variables
                const newInstance = {};
                if (nodeData.instances.length > 0) {
                    // Copy structure from first instance
                    Object.keys(nodeData.instances[0]).forEach(key => {
                        newInstance[key] = '';
                    });
                }
                
                nodeData.instances.push(newInstance);
                
                // Update the main node data
                const nodeInfo = this.nodes.get(this.currentTemplateNodeId);
                if (nodeInfo) {
                    nodeInfo.data.instances = nodeData.instances;
                }
                
                // Refresh display
                this.enterTemplateView(this.currentTemplateNodeId);
                
                // Update overview connections
                setTimeout(() => this.updateConnections(), 100);
            }

            removeTemplateInstance(index) {
                const configData = this.getCurrentConfigData();
                const nodeData = configData[this.currentTemplateNodeId];
                if (nodeData.instances && nodeData.instances.length > 1) {
                    nodeData.instances.splice(index, 1);
                    
                    // Update the main node data
                    const nodeInfo = this.nodes.get(this.currentTemplateNodeId);
                    if (nodeInfo) {
                        nodeInfo.data.instances = nodeData.instances;
                    }
                    
                    this.enterTemplateView(this.currentTemplateNodeId);
                    
                    // Update overview connections
                    setTimeout(() => this.updateConnections(), 100);
                }
            }

            updateInstanceVariable(instanceIndex, variable, value) {
                const configData = this.getCurrentConfigData();
                const nodeData = configData[this.currentTemplateNodeId];
                if (nodeData.instances && nodeData.instances[instanceIndex]) {
                    nodeData.instances[instanceIndex][variable] = value;
                    
                    // Update the main node data
                    const nodeInfo = this.nodes.get(this.currentTemplateNodeId);
                    if (nodeInfo) {
                        nodeInfo.data.instances = nodeData.instances;
                    }
                    
                    // Update overview connections since variable changes affect connections
                    setTimeout(() => this.updateConnections(), 100);
                }
            }

            showAddTemplateNodeModal() {
                // Reuse the existing add node modal
                document.getElementById('newNodeId').value = '';
                document.getElementById('newNodeType').value = '';
                this.updateNodeTypeDescription('');
                
                // Mark that we're adding to template
                this.addingToTemplate = true;
                this.addNodeModal.classList.remove('hidden');
            }

            addTemplateNode(nodeId, nodeType) {
                // Find a good position for the new node
                const existingNodes = this.templateCanvas.querySelectorAll('.node');
                let x = 100;
                let y = 100;
                
                // Try to find an empty spot
                while (this.isPositionOccupied(x, y, existingNodes)) {
                    x += 200;
                    if (x > 800) {
                        x = 100;
                        y += 150;
                    }
                }

                // Create the node data
                const nodeData = { type: nodeType };
                
                // Add to template data
                const configData = this.getCurrentConfigData();
                const templateNodeData = configData[this.currentTemplateNodeId];
                if (!templateNodeData.template) templateNodeData.template = {};
                templateNodeData.template[nodeId] = nodeData;
                
                // Update the main node data
                const mainNodeInfo = this.nodes.get(this.currentTemplateNodeId);
                if (mainNodeInfo) {
                    mainNodeInfo.data.template = templateNodeData.template;
                }

                // Create the visual node in template canvas
                const nodeElement = this.createUnifiedNode(nodeId, nodeData, x, y, {
                    isTemplateNode: true,
                    highlightPlaceholders: true,
                    containerElement: this.templateCanvas,
                    nodesMap: new Map() // Template nodes don't need to be in main nodes map
                });

                // Add delete button to template nodes
                this.addDeleteButtonToNode(nodeElement, nodeId);
                
                // Update connections
                this.updateTemplateConnections();
                
                // Mark as modified
                this.hasUnsavedChanges = true;
            }

            addDeleteButtonToNode(nodeElement, nodeId) {
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'node-delete-btn';
                deleteBtn.innerHTML = '×';
                deleteBtn.title = 'Delete node';
                deleteBtn.style.cssText = `
                    position: absolute;
                    top: -8px;
                    right: -8px;
                    width: 20px;
                    height: 20px;
                    border-radius: 50%;
                    border: none;
                    background: #ef4444;
                    color: white;
                    font-size: 12px;
                    cursor: pointer;
                    display: none;
                    align-items: center;
                    justify-content: center;
                    font-weight: bold;
                `;

                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.deleteTemplateNode(nodeId);
                });

                // Show delete button on hover
                nodeElement.addEventListener('mouseenter', () => {
                    deleteBtn.style.display = 'flex';
                });
                nodeElement.addEventListener('mouseleave', () => {
                    deleteBtn.style.display = 'none';
                });

                nodeElement.style.position = 'relative';
                nodeElement.appendChild(deleteBtn);
            }

            deleteTemplateNode(nodeId) {
                if (confirm(`Are you sure you want to delete the node "${nodeId}"?`)) {
                    // Remove from template data
                    const configData = this.getCurrentConfigData();
                    const templateNodeData = configData[this.currentTemplateNodeId];
                    if (templateNodeData.template && templateNodeData.template[nodeId]) {
                        delete templateNodeData.template[nodeId];
                        
                        // Update the main node data
                        const mainNodeInfo = this.nodes.get(this.currentTemplateNodeId);
                        if (mainNodeInfo) {
                            mainNodeInfo.data.template = templateNodeData.template;
                        }
                    }

                    // Remove the visual node
                    const nodeElement = this.templateCanvas.querySelector(`[data-node-id="${nodeId}"]`);
                    if (nodeElement) {
                        nodeElement.remove();
                    }

                    // Update connections
                    this.updateTemplateConnections();
                    
                    // Mark as modified
                    this.hasUnsavedChanges = true;
                }
            }

            isPositionOccupied(x, y, existingNodes) {
                const buffer = 50; // Minimum distance between nodes
                for (const node of existingNodes) {
                    const nodeX = parseInt(node.style.left) || 0;
                    const nodeY = parseInt(node.style.top) || 0;
                    if (Math.abs(nodeX - x) < buffer && Math.abs(nodeY - y) < buffer) {
                        return true;
                    }
                }
                return false;
            }

            // Override confirmAddNode to handle template nodes
            confirmAddNode() {
                const nodeId = document.getElementById('newNodeId').value.trim();
                const nodeType = document.getElementById('newNodeType').value;
                
                if (!nodeId) {
                    this.showError('Please enter a node ID');
                    return;
                }
                
                if (!nodeType) {
                    this.showError('Please select a node type');
                    return;
                }
                
                // Check if adding to template
                if (this.addingToTemplate) {
                    // Check if node ID already exists in template
                    const configData = this.getCurrentConfigData();
                    const templateNodeData = configData[this.currentTemplateNodeId];
                    if (templateNodeData.template && templateNodeData.template[nodeId]) {
                        this.showError('Node ID already exists in template!');
                        return;
                    }
                    
                    this.addTemplateNode(nodeId, nodeType);
                    this.addingToTemplate = false;
                } else {
                    // Check if node ID already exists in main config
                    if (this.nodes.has(nodeId)) {
                        this.showError('Node ID already exists!');
                        return;
                    }
                    
                    this.createNewNode(nodeId, nodeType);
                }
                
                this.closeAddNodeModal();
            }

            handleMouseDown(e) {
                const nodeElement = e.target.closest('.node');
                if (nodeElement) {
                    // Calculate drag offset more precisely accounting for transforms
                    const isTemplateCanvas = e.target.closest('#templateCanvas') || e.target.closest('.template-canvas-container');
                    
                    // Get the container rect (untransformed)
                    const containerRect = isTemplateCanvas ? 
                        document.querySelector('.template-canvas-container').getBoundingClientRect() :
                        document.querySelector('.canvas-container').getBoundingClientRect();
                    
                    const currentScale = isTemplateCanvas ? this.templateScale : this.scale;
                    const currentOffset = isTemplateCanvas ? this.templateCanvasOffset : this.canvasOffset;
                    
                    // Calculate mouse position in canvas coordinates
                    const mouseXInContainer = e.clientX - containerRect.left;
                    const mouseYInContainer = e.clientY - containerRect.top;
                    
                    // Get node's current position in canvas coordinates
                    const nodeLeft = parseFloat(nodeElement.style.left) || 0;
                    const nodeTop = parseFloat(nodeElement.style.top) || 0;
                    
                    // Calculate offset from mouse to node origin in canvas coordinates
                    const canvasMouseX = (mouseXInContainer - currentOffset.x) / currentScale;
                    const canvasMouseY = (mouseYInContainer - currentOffset.y) / currentScale;
                    
                    this.dragOffset = {
                        x: canvasMouseX - nodeLeft,
                        y: canvasMouseY - nodeTop
                    };
                    
                    this.isDragging = nodeElement;
                    this.selectNode(nodeElement);
                    
                    // Determine which canvas we're in
                    const templateCanvas = document.getElementById('templateCanvas');
                    this.draggingInTemplate = templateCanvas.contains(nodeElement);
                    
                    e.preventDefault();
                } else {
                    // Start panning when clicking on canvas (not on a node)
                    const isTemplateCanvas = e.target.closest('#templateCanvas') || e.target.closest('.template-canvas-container');
                    const isInMainCanvas = e.target.closest('#canvas') || e.target.closest('.canvas-container');
                    
                    if (isTemplateCanvas) {
                        this.templateIsPanning = true;
                        this.templatePanStart = { x: e.clientX, y: e.clientY };
                        this.templateCanvas.style.cursor = 'grabbing';
                    } else if (isInMainCanvas) {
                        this.isPanning = true;
                        this.panStart = { x: e.clientX, y: e.clientY };
                        this.canvas.style.cursor = 'grabbing';
                    }
                    e.preventDefault();
                }
            }

            handleMouseMove(e) {
                if (this.isPanning) {
                    // Handle main canvas panning
                    const deltaX = e.clientX - this.panStart.x;
                    const deltaY = e.clientY - this.panStart.y;
                    
                    this.canvasOffset.x += deltaX;
                    this.canvasOffset.y += deltaY;
                    
                    this.panStart.x = e.clientX;
                    this.panStart.y = e.clientY;
                    
                    this.updateCanvasTransform();
                } else if (this.templateIsPanning) {
                    // Handle template canvas panning
                    const deltaX = e.clientX - this.templatePanStart.x;
                    const deltaY = e.clientY - this.templatePanStart.y;
                    
                    this.templateCanvasOffset.x += deltaX;
                    this.templateCanvasOffset.y += deltaY;
                    
                    this.templatePanStart.x = e.clientX;
                    this.templatePanStart.y = e.clientY;
                    
                    this.updateTemplateCanvasTransform();
                } else if (this.isDragging) {
                    // Handle node dragging
                    let canvasRect;
                    let currentScale, currentOffset;
                    
                    if (this.draggingInTemplate) {
                        canvasRect = this.templateCanvas.getBoundingClientRect();
                        currentScale = this.templateScale;
                        currentOffset = this.templateCanvasOffset;
                    } else {
                        canvasRect = this.canvas.getBoundingClientRect();
                        currentScale = this.scale;
                        currentOffset = this.canvasOffset;
                    }
                    
                    // Calculate mouse position in canvas coordinates, accounting for zoom and pan
                    // First, get the mouse position relative to the canvas container (not the transformed canvas)
                    const containerRect = this.draggingInTemplate ? 
                        document.querySelector('.template-canvas-container').getBoundingClientRect() :
                        document.querySelector('.canvas-container').getBoundingClientRect();
                    
                    const mouseXInContainer = e.clientX - containerRect.left;
                    const mouseYInContainer = e.clientY - containerRect.top;
                    
                    // Convert to canvas internal coordinates (accounting for scale and offset)
                    const x = (mouseXInContainer - currentOffset.x - this.dragOffset.x) / currentScale;
                    const y = (mouseYInContainer - currentOffset.y - this.dragOffset.y) / currentScale;
                    
                    this.isDragging.style.left = `${x}px`;
                    this.isDragging.style.top = `${y}px`;
                    
                    // Update stored position for main canvas nodes
                    if (!this.draggingInTemplate) {
                        for (const [nodeId, nodeInfo] of this.nodes) {
                            if (nodeInfo.element === this.isDragging) {
                                nodeInfo.position = { x, y };
                                break;
                            }
                        }
                    }
                    
                    // Update connections while dragging
                    if (this.draggingInTemplate) {
                        this.updateTemplateConnections();
                    } else {
                        this.updateConnections();
                    }
                }
            }

            handleMouseUp(e) {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.draggingInTemplate = false;
                    this.hasUnsavedChanges = true;
                }
                if (this.isPanning) {
                    this.isPanning = false;
                    this.canvas.style.cursor = 'grab';
                }
                if (this.templateIsPanning) {
                    this.templateIsPanning = false;
                    this.templateCanvas.style.cursor = 'grab';
                }
            }

            handleWheel(e) {
                e.preventDefault();
                
                const isTemplateCanvas = e.target.closest('#templateCanvas') || e.target.closest('.template-canvas-container');
                const canvas = isTemplateCanvas ? this.templateCanvas : this.canvas;
                const rect = canvas.getBoundingClientRect();
                
                // Get mouse position relative to canvas
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Current scale and offset
                const currentScale = isTemplateCanvas ? this.templateScale : this.scale;
                const currentOffset = isTemplateCanvas ? this.templateCanvasOffset : this.canvasOffset;
                
                // Calculate zoom factor (very reduced speed for better UX)
                const zoomFactor = e.deltaY > 0 ? 0.9875 : 1.0125;
                const newScale = Math.max(this.minScale, Math.min(this.maxScale, currentScale * zoomFactor));
                
                if (newScale !== currentScale) {
                    // Calculate new offset to zoom around mouse position
                    const scaleChange = newScale / currentScale;
                    const newOffsetX = mouseX - (mouseX - currentOffset.x) * scaleChange;
                    const newOffsetY = mouseY - (mouseY - currentOffset.y) * scaleChange;
                    
                    if (isTemplateCanvas) {
                        this.templateScale = newScale;
                        this.templateCanvasOffset = { x: newOffsetX, y: newOffsetY };
                        this.updateTemplateCanvasTransform();
                    } else {
                        this.scale = newScale;
                        this.canvasOffset = { x: newOffsetX, y: newOffsetY };
                        this.updateCanvasTransform();
                    }
                    
                    this.updateZoomDisplay();
                }
            }

            updateCanvasTransform() {
                const transform = `translate(${this.canvasOffset.x}px, ${this.canvasOffset.y}px) scale(${this.scale})`;
                this.canvas.style.transform = transform;
                this.canvas.style.transformOrigin = '0 0';
            }

            updateTemplateCanvasTransform() {
                const transform = `translate(${this.templateCanvasOffset.x}px, ${this.templateCanvasOffset.y}px) scale(${this.templateScale})`;
                this.templateCanvas.style.transform = transform;
                this.templateCanvas.style.transformOrigin = '0 0';
            }

            resetZoomAndPan() {
                this.scale = 1.0;
                this.canvasOffset = { x: 0, y: 0 };
                this.updateCanvasTransform();
            }

            resetTemplateZoomAndPan() {
                this.templateScale = 1.0;
                this.templateCanvasOffset = { x: 0, y: 0 };
                this.updateTemplateCanvasTransform();
            }

            zoomIn() {
                if (this.isInTemplateView) {
                    this.templateScale = Math.min(this.maxScale, this.templateScale * 1.2);
                    this.updateTemplateCanvasTransform();
                } else {
                    this.scale = Math.min(this.maxScale, this.scale * 1.2);
                    this.updateCanvasTransform();
                }
                this.updateZoomDisplay();
            }

            zoomOut() {
                if (this.isInTemplateView) {
                    this.templateScale = Math.max(this.minScale, this.templateScale / 1.2);
                    this.updateTemplateCanvasTransform();
                } else {
                    this.scale = Math.max(this.minScale, this.scale / 1.2);
                    this.updateCanvasTransform();
                }
                this.updateZoomDisplay();
            }

            resetZoom() {
                if (this.isInTemplateView) {
                    this.resetTemplateZoomAndPan();
                } else {
                    this.resetZoomAndPan();
                }
                this.updateZoomDisplay();
            }

            updateZoomDisplay() {
                const currentScale = this.isInTemplateView ? this.templateScale : this.scale;
                const zoomPercent = Math.round(currentScale * 100);
                const zoomLevelElement = document.getElementById('zoomLevel');
                if (zoomLevelElement) {
                    zoomLevelElement.textContent = `${zoomPercent}%`;
                }
            }
        }

        // Initialize the editor when the page loads
        let editor;
        document.addEventListener('DOMContentLoaded', () => {
            editor = new ConfigurationEditor();
        });
    </script>
</body>
</html>