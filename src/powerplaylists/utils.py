from __future__ import annotations

import enum
import os
import pathlib
import sys
from typing import Any

import yaml


def is_macos() -> bool:
    return sys.platform == "darwin"


def to_bool(bool_or_str: str | bool | None) -> bool:
    if bool_or_str is None:
        return False
    elif isinstance(bool_or_str, bool):
        return bool_or_str
    else:
        return bool(str(bool_or_str).lower() in ("t", "true"))


class VerifyMode(enum.Enum):
    NONE = "No verification"
    END = "Verify after all updates to a single playlist"
    INCREMENTAL = "Verify after each update to a playlist"


class Constants:
    APP_HOMEDIR = os.path.expanduser("~/.power-playlists")
    APP_CONFIG_FILE_DEFAULT = f"{APP_HOMEDIR}/conf.yaml"

    AUTOGEN_PLAYLIST_DESCRIPTION = "Playlist auto-generated by power-playlists"
    SECURITY_SCOPES = (
        "playlist-read-collaborative playlist-modify-public playlist-read-private "
        "playlist-modify-private user-library-modify user-library-read"
    )

    PAGINATION_LIMIT = 50

    CLIENT_ID_DEFAULT = "6c0cbb650d164b848f0aa8ef76c1359e"
    CLIENT_REDIRECT_URI_DEFAULT = "http://localhost:5050"
    USER_CONFIG_DIR_DEFAULT = f"{APP_HOMEDIR}/userconf"
    CACHE_DIR_DEFAULT = f"{APP_HOMEDIR}/cache"
    LOG_FILE_PATH_DEFAULT = f"{APP_HOMEDIR}/app.log"
    LOG_FILE_LEVEL_DEFAULT = "INFO"
    DAEMON_SLEEP_PERIOD_MINUTES_DEFAULT = 60 * 12
    DAEMON_PIDFILE_DEFAULT = f"{APP_HOMEDIR}/daemon.pid"
    VERIFY_MODE_DEFAULT = VerifyMode.END

    PACKAGE_HIERARCHICAL_NAME = "com.github.xkrogen.power-playlists"
    MACOS_LAUNCHD_AGENT_DIR = "~/Library/LaunchAgents"
    MACOS_LAUNCHD_PLIST_FILE = f"{MACOS_LAUNCHD_AGENT_DIR}/{PACKAGE_HIERARCHICAL_NAME}.plist"
    MACOS_LAUNCHD_PLIST_FORMAT = """
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
    <dict>
        <key>Label</key>
        <string>{scriptid}</string>
        <key>ProgramArguments</key>
        <array>
            <string>{entrypoint}</string>
            {appconf_param_str}
            <string>run</string>
        </array>
        <key>StandardErrorPath</key>
        <string>{stderr}</string>
        <key>StandardOutPath</key>
        <string>{stdout}</string>
        <key>ProcessType</key>
        <string>Background</string>
        <key>StartInterval</key>
        <integer>{run_interval}</integer>
    </dict>
    </plist>
    """


global_conf: AppConfig | None = None


class AppConfig:
    def __init__(self, app_config_path: str | os.PathLike[str] | None = None):
        self.client_id = Constants.CLIENT_ID_DEFAULT
        self.client_redirect_uri = Constants.CLIENT_REDIRECT_URI_DEFAULT
        self.user_config_dir = Constants.USER_CONFIG_DIR_DEFAULT
        self.cache_dir = Constants.CACHE_DIR_DEFAULT
        self.log_file_path = Constants.LOG_FILE_PATH_DEFAULT
        self.log_file_level = Constants.LOG_FILE_LEVEL_DEFAULT
        self.daemon_sleep_period_minutes = Constants.DAEMON_SLEEP_PERIOD_MINUTES_DEFAULT
        self.daemon_pidfile = Constants.DAEMON_PIDFILE_DEFAULT
        self.verify_mode = Constants.VERIFY_MODE_DEFAULT
        self.cache_force = False
        self.app_config_path = app_config_path
        if app_config_path is not None:
            if not os.path.isfile(app_config_path):
                raise ValueError(f"Received invalid app_config_path: {app_config_path}")
            self.__load_from_file(app_config_path)
        elif os.path.isfile(Constants.APP_CONFIG_FILE_DEFAULT):
            self.__load_from_file(Constants.APP_CONFIG_FILE_DEFAULT)

        for path in [
            pathlib.Path(Constants.APP_HOMEDIR),
            pathlib.Path(self.user_config_dir),
            pathlib.Path(self.cache_dir),
            pathlib.Path(self.log_file_path).parent,
            pathlib.Path(self.daemon_pidfile).parent,
        ]:
            path.mkdir(parents=True, exist_ok=True)

    def __load_from_file(self, path: str | os.PathLike[str]) -> None:
        with open(path) as conf_file:
            conf_yaml = yaml.safe_load(conf_file)

        def get_or_default(key: str, default: Any) -> Any:
            return conf_yaml.get(key, default)

        self.client_id = get_or_default("client_id", self.client_id)
        self.client_redirect_uri = get_or_default("client_redirect_uri", self.client_redirect_uri)
        self.user_config_dir = get_or_default("user_config_dir", self.user_config_dir)
        self.cache_dir = get_or_default("cache_dir", self.cache_dir)
        self.log_file_path = get_or_default("log_file_path", self.log_file_path)
        self.log_file_level = get_or_default("log_file_level", self.log_file_level)
        self.daemon_sleep_period_minutes = get_or_default(
            "daemon_sleep_period_minutes", self.daemon_sleep_period_minutes
        )
        self.daemon_pidfile = get_or_default("daemon_pidfile", self.daemon_pidfile)
        self.verify_mode = VerifyMode[get_or_default("verify_mode", self.verify_mode.name).upper()]

    def get_user_config_files(self, user_config_file_paths: list[str] | None = None) -> list[str]:
        if user_config_file_paths is not None and len(user_config_file_paths) != 0:
            for user_config_file_path in user_config_file_paths:
                if not os.path.isfile(user_config_file_path):
                    raise ValueError(f"Invalid user config file path supplied: {user_config_file_path}")
            return user_config_file_paths
        elif os.path.isdir(self.user_config_dir):
            filenames = os.listdir(self.user_config_dir)
            yaml_files = [f"{self.user_config_dir}/{f}" for f in filenames if f.endswith(".yaml")]
            if len(yaml_files) == 0:
                raise ValueError(f"Found valid user config directory but it was empty: {self.user_config_dir}")
            return yaml_files
        else:
            raise ValueError(f"Unable to find user config directory, searched for: {self.user_config_dir}")


class UserConfig:
    def __init__(self, user_config_path: str | os.PathLike[str]):
        with open(user_config_path) as conf_file:
            conf_yaml = yaml.safe_load(conf_file)
        if not isinstance(conf_yaml, dict) or len(conf_yaml) < 1:
            raise ValueError(f"Invalid node definition found within user conf file: {user_config_path}")
        self.node_dicts: dict[str, dict[str, Any]] = conf_yaml
