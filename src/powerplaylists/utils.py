from __future__ import annotations

import enum
import os
import sys
from typing import *

import yaml


def is_macos() -> bool:
    return sys.platform == 'darwin'


def to_bool(bool_or_str: Optional[Union[str, bool]]) -> bool:
    if bool_or_str is None:
        return False
    elif isinstance(bool_or_str, bool):
        return bool_or_str
    else:
        return bool(str(bool_or_str).lower() in ('t', 'true'))


class VerifyMode(enum.Enum):
    NONE = 'No verification'
    END = 'Verify after all updates to a single playlist'
    INCREMENTAL = 'Verify after each update to a playlist'


class Constants:
    APP_HOMEDIR = os.path.expanduser('~/.power-playlists')
    APP_CONFIG_FILE_DEFAULT = f'{APP_HOMEDIR}/conf.yaml'

    AUTOGEN_PLAYLIST_DESCRIPTION = 'Playlist auto-generated by power-playlists'
    SECURITY_SCOPES = 'playlist-read-collaborative playlist-modify-public playlist-read-private ' \
                      'playlist-modify-private user-library-modify user-library-read'

    PAGINATION_LIMIT = 50

    CLIENT_ID_DEFAULT = '6c0cbb650d164b848f0aa8ef76c1359e'
    CLIENT_REDIRECT_URI_DEFAULT = 'http://localhost:5050'
    USER_CONFIG_DIR_DEFAULT = f'{APP_HOMEDIR}/userconf'
    CACHE_DIR_DEFAULT = f'{APP_HOMEDIR}/cache'
    LOG_FILE_PATH_DEFAULT = f'{APP_HOMEDIR}/app.log'
    LOG_FILE_LEVEL_DEFAULT = 'INFO'
    DAEMON_SLEEP_PERIOD_MINUTES_DEFAULT = 60 * 12
    DAEMON_PIDFILE_DEFAULT = f'{APP_HOMEDIR}/daemon.pid'
    VERIFY_MODE_DEFAULT = VerifyMode.END

    PACKAGE_HIERARCHICAL_NAME = 'com.github.xkrogen.power-playlists'
    MACOS_LAUNCHD_AGENT_DIR = '~/Library/LaunchAgents'
    MACOS_LAUNCHD_PLIST_FILE = f'{MACOS_LAUNCHD_AGENT_DIR}/{PACKAGE_HIERARCHICAL_NAME}.plist'
    MACOS_LAUNCHD_PLIST_FORMAT = """
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
    <dict>
        <key>Label</key>
        <string>{scriptid}</string>
        <key>ProgramArguments</key>
        <array>
            <string>{entrypoint}</string>
            {appconf_param_str}
            <string>run</string>
        </array>
        <key>StandardErrorPath</key>
        <string>{stderr}</string>
        <key>StandardOutPath</key>
        <string>{stdout}</string>
        <key>ProcessType</key>
        <string>Background</string>
        <key>StartInterval</key>
        <integer>{run_interval}</integer>
    </dict>
    </plist>
    """


global_conf: Union[AppConfig, None] = None


class AppConfig:
    def __init__(self, app_config_path: Union[str, os.PathLike[str], None] = None):
        self.client_id = Constants.CLIENT_ID_DEFAULT
        self.client_redirect_uri = Constants.CLIENT_REDIRECT_URI_DEFAULT
        self.user_config_dir = Constants.USER_CONFIG_DIR_DEFAULT
        self.cache_dir = Constants.CACHE_DIR_DEFAULT
        self.log_file_path = Constants.LOG_FILE_PATH_DEFAULT
        self.log_file_level = Constants.LOG_FILE_LEVEL_DEFAULT
        self.daemon_sleep_period_minutes = Constants.DAEMON_SLEEP_PERIOD_MINUTES_DEFAULT
        self.daemon_pidfile = Constants.DAEMON_PIDFILE_DEFAULT
        self.verify_mode = Constants.VERIFY_MODE_DEFAULT
        self.cache_force = False
        self.app_config_path = app_config_path
        if app_config_path is not None:
            if not os.path.isfile(app_config_path):
                raise ValueError(f'Received invalid app_config_path: {app_config_path}')
            self.__load_from_file(app_config_path)
        elif os.path.isfile(Constants.APP_CONFIG_FILE_DEFAULT):
            self.__load_from_file(Constants.APP_CONFIG_FILE_DEFAULT)

    def __load_from_file(self, path: Union[str, os.PathLike[str]]) -> None:
        with open(path) as conf_file:
            conf_yaml = yaml.safe_load(conf_file)

        def get_or_default(key: str, default: Any) -> Any:
            return conf_yaml[key] if key in conf_yaml else default

        self.client_id = get_or_default('client_id', self.client_id)
        self.client_redirect_uri = get_or_default('client_redirect_uri', self.client_redirect_uri)
        self.user_config_dir = get_or_default('user_config_dir', self.user_config_dir)
        self.cache_dir = get_or_default('cache_dir', self.cache_dir)
        self.log_file_path = get_or_default('log_file_path', self.log_file_path)
        self.log_file_level = get_or_default('log_file_level', self.log_file_level)
        self.daemon_sleep_period_minutes = get_or_default('daemon_sleep_period_minutes',
                                                          self.daemon_sleep_period_minutes)
        self.daemon_pidfile = get_or_default('daemon_pidfile', self.daemon_pidfile)
        self.verify_mode = VerifyMode[get_or_default('verify_mode', self.verify_mode.name).upper()]

    def get_user_config_files(self, user_config_file_paths: Optional[List[str]] = None) -> List[str]:
        if user_config_file_paths is not None and len(user_config_file_paths) != 0:
            for user_config_file_path in user_config_file_paths:
                if not os.path.isfile(user_config_file_path):
                    raise ValueError(f'Invalid user config file path supplied: {user_config_file_path}')
            return user_config_file_paths
        elif os.path.isdir(self.user_config_dir):
            filenames = os.listdir(self.user_config_dir)
            yaml_files = [f'{self.user_config_dir}/{f}' for f in filenames if f.endswith('.yaml')]
            if len(yaml_files) == 0:
                raise ValueError(f'Found valid user config directory but it was empty: {self.user_config_dir}')
            return yaml_files
        else:
            raise ValueError(f'Unable to find user config directory, searched for: {self.user_config_dir}')


class UserConfig:
    def __init__(self, user_config_path: Union[str, os.PathLike[str]]):
        with open(user_config_path) as conf_file:
            conf_yaml = yaml.safe_load(conf_file)
        if not isinstance(conf_yaml, Dict) or len(conf_yaml) < 1:
            raise ValueError(f'Invalid node definition found within user conf file: {user_config_path}')
        self.node_dicts: Dict[str, Dict[str, Any]] = conf_yaml
